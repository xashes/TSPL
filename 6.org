#+OPTIONS: toc:nil
* 6. 对象操作

本章介绍了针对各种对象的操作，包括列表，数字，字符，字符串，向量，字节向量，符号，布尔值，哈希表，以及枚举类型。第一节涵盖了常量对象和引用。第二节介绍了用于比较两个对象的通用等价性谓词，及判定对象类型的谓词。随后的几节介绍了主要用于处理上述某一类型对象的过程。本章中没有介绍过程操作的内容，因为唯一一个专门为过程定义的操作是 application, 而它已经在第 5 章中介绍过了。端口操作在第 7 章关于输入输出的更一般性的讨论中会介绍。定义新数据类型的机制会在第 9 章中介绍。

** Section 6.1. Constants 和 Quotation

syntax: constant

returns: constant


~constant~ 是任何自求值常量，即，数字，布尔值，字符，字符串，或字节向量。常量是不可变的；参见下文对引用的介绍的注解。

#+BEGIN_SRC scheme
  3.2 => 3.2
  #f => #f
  #\c => #\c
  "hi" => "hi"
  #vu8(3 4 5) => #vu8(3 4 5)
#+END_SRC


syntax: (quote obj)

syntax: 'obj

returns: obj

libraries: (rnrs base), (rnrs)


'obj 等价于 (quote obj). Scheme 读取器（参见“读取”）会把缩写形式转化为完整形式。

quote 阻止了对 obj 的常规求值规则，允许 obj 被作为数据使用。虽然任何 Scheme 对象都可以被引用，但没必要引用自求值常量，即，数字，布尔值，字符，字符串和字节向量。

Quoted 和 self-evaluating constants are immutable. That is, programs should not alter a constant via set-car!, string-set!, etc., 和 implementations are permitted to raise an exception with condition type &assertion if such an alteration is attempted. If an attempt to alter an immutable object is undetected, the behavior of the program is unspecified. An implementation may choose to share storage among different constants to save space.
引用的和自求值的常量是不可变的。即，程序不应通过 set-car!, string-set! 等过程修改常量，如果尝试做出这种修改，具体实现可以抛出一个条件类型的 &assertion 异常。如果修改不可变对象的尝试没有被检测到，程序的行为就会不可知。一种实现可以选择使不同的常量共享存储以节省空间。

#+BEGIN_SRC scheme
  (+ 2 3) => 5
  '(+ 2 3) => (+ 2 3)
  (quote (+ 2 3)) => (+ 2 3)
  'a => a
  'cons => cons
  '() => ()
  '7 => 7
#+END_SRC


syntax: (quasiquote obj ...)

syntax: `obj

syntax: (unquote obj ...)

syntax: ,obj

syntax: (unquote-splicing obj ...)

syntax: ,@obj

returns: 参见下文

libraries: (rnrs base), (rnrs)


`obj 等价于 (quasiquote obj), ,obj 等价于 (unquote obj), 而 ,@obj 等价于 (unquote-splicing obj). Scheme 读取器（参见“读取”）会把缩写形式转化为完整形式。

quasiquote 类似于 quote, 但它允许引用内容的一部分被解除引用。在一个 quasiquote 表达式中，unquote 和 unquote-splicing 衍生形式被求值，而其它一切内容都是引用的，即，保留为未求值的。每个 unquote 衍生形式的值会替换掉 unquote 形式，插入到输出中，而每个 unquote-splicing 衍生形式的值会被拼接进外围的列表或向量结构中。unquote 和 unquote-splicing 只在 quasiquote 表达式中有效。

quasiquote 表达式可以嵌套，每个 quasiquote 引入一层新的引用，而每个 unquote 或 unquote-splicing 解除一层引用。如果一个表达式嵌套在 n 层 quasiquote 表达式中，则它必须通过 n 层 unquote 或 unquote-splicing 才能被求值。

#+BEGIN_SRC scheme
  `(+ 2 3) => (+ 2 3)

  `(+ 2 ,(* 3 4)) => (+ 2 12)
  `(a b (,(+ 2 3) c) d) => (a b (5 c) d)
  `(a b ,(reverse '(c d e)) f g) => (a b (e d c) f g)
  (let ([a 1] [b 2])
    `(,a . ,b)) => (1 . 2)

  `(+ ,@(cdr '(* 2 3))) => (+ 2 3)
  `(a b ,@(reverse '(c d e)) f g) => (a b e d c f g)
  (let ([a 1] [b 2])
    `(,a ,@b)) => (1 . 2)
  `#(,@(list 1 2 3)) => #(1 2 3)

  '`,(cons 'a 'b) => `,(cons 'a 'b)
  `',(cons 'a 'b) => '(a . b)
#+END_SRC


带有 0 个或多于 1 个子形式的 unquote 和 unquote-splicing 语法形式只在拼接环境（列表或向量）中有效。 (unquote obj ...) 等价于 (unquote obj) ..., 而 (unquote-splicing obj ...) 等价于 (unquote-splicing obj) .... 这些形式主要作为 quasiquote 展开器输出的中间形式。它们支持某些有用的 quasiquote 嵌套惯用法 [3], 比如 ,@,@, 在双重嵌套和双重求值的 quasiquote 表达式中使用时，有双重间接拼接的作用。

#+BEGIN_SRC scheme
  `(a (unquote) b) => (a b)
  `(a (unquote (+ 3 3)) b) => (a 6 b)
  `(a (unquote (+ 3 3) (* 3 3)) b) => (a 6 9 b)

  (let ([x '(m n)]) ``(a ,@,@x f)) => `(a (unquote-splicing m n) f)
  (let ([x '(m n)])
    (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
          (environment '(rnrs)))) => (a b c d e f)
#+END_SRC

unquote 和 unquote-splicing 是 quasiquote 的辅助关键字。在它们作为辅助关键字的环境以外引用这些标识符是违反语法的。


** Section 6.2. 通用的等价性和类型谓词

本节介绍了基本的 Scheme 谓词（返回布尔值 #t 或 #f 的过程），用于判定对象的类型或两个对象的等价性。先讨论等价性谓词 eq?, eqv?, 和 equal?, 接下来是类型谓词。

procedure: ~(eq? obj1 obj2)~

返回: 如果 ~obj1~ 和 ~obj2~ 完全相同，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


在大多数 Scheme 系统中，如果两个对象内部通过相同的指针值表示，则被认为是完全相同的，如果它们在内部以不同的指针值表示，则被认为是不同的。不过也有采用其它标准的情况，比如利用时间戳判定。

虽然不同系统之间判定对象同一性的特定规则会有些微的不同，但以下规则总是成立的。

    两个不同类型（布尔类型，空列表，点对，数字，字符，字符串，向量，符号，及过程）的对象是不同的。

    两个内容或值不相同的同类型对象是不同的。

    不论在哪里出现，布尔对象 #t 与其自身都是相同的。不论出现在哪里，#f 也与其自身相同。但#t 与#f 不同。

    不论出现在哪里，空列表 () 都与其自身相同。

    当且仅当两个符号的名字相同时（通过 string=?判定），它们相同。

    一个常量点对，向量，字符串或字节向量与其自身相同，比如通过应用 cons, vector, string, make-bytevector 等创建的点对，向量，字符串或字节向量。通过对 cons, vector, string, make-bytevector 等的不同应用创建的两个点对，向量，字符串或字节向量是不同的。由此可得的一个推论是，比如说，cons，可以被用于创建一个和所有其它对象都不同的唯一性对象。

    两个行为可能不同的过程是不同的。通过求值一个 lambda 表达式创建的过程与其自身相同。两个通过相同 lambda 表达式在不同时间创建的过程，或通过相似 lambda 表达式创建的过程，可能相同，也可能不同。

eq? 用于比较数字和字符时并不可靠。尽管每个不精确的数字与每个精确的数字都不同，但拥有相同值的两个精确的数字，两个不精确的数字，或两个字符，都可能相同，也可能不同。

Since constant objects are immutable, i.e., programs should not modify them via vector-set!, set-car!, or any other structure mutation operation, all or portions of different quoted constants or self-evaluating literals may be represented internally by the same object. Thus, eq? may return #t when applied to equal parts of different immutable constants.
由于常量对象是不可变的，即，程序不应通过 vector-set!, set-car!, 或任何其它结构修改操作修改它们，不同的引用常量或自求值字面量的全部或部分可能在内部由同一个对象表示。于是，当应用于不同的不可变常量的相等部分时，eq? 可能返回 #t.

eq? 最常用于比较符号，或检查分配对象的指针等价性，例如，点对，向量，或 record 实例。

#+BEGIN_SRC scheme
  (eq? 'a 3) => #f
  (eq? #t 't) => #f
  (eq? "abc" 'abc) => #f
  (eq? "hi" '(hi)) => #f
  (eq? #f '()) => #f

  (eq? 9/2 7/2) => #f
  (eq? 3.4 53344) => #f
  (eq? 3 3.0) => #f
  (eq? 1/3 #i1/3) => #f

  (eq? 9/2 9/2) => unspecified
  (eq? 3.4 (+ 3.0 .4)) => unspecified
  (let ([x (* 12345678987654321 2)])
    (eq? x x)) => unspecified

  (eq? #\a #\b) => #f
  (eq? #\a #\a) => unspecified
  (let ([x (string-ref "hi" 0)])
    (eq? x x)) => unspecified

  (eq? #t #t) => #t
  (eq? #f #f) => #t
  (eq? #t #f) => #f
  (eq? (null? '()) #t) => #t
  (eq? (null? '(a)) #f) => #t

  (eq? (cdr '(a)) '()) => #t

  (eq? 'a 'a) => #t
  (eq? 'a 'b) => #f
  (eq? 'a (string->symbol "a")) => #t

  (eq? '(a) '(b)) => #f
  (eq? '(a) '(a)) => unspecified
  (let ([x '(a . b)]) (eq? x x)) => #t
  (let ([x (cons 'a 'b)])
    (eq? x x)) => #t
  (eq? (cons 'a 'b) (cons 'a 'b)) => #f

  (eq? "abc" "cba") => #f
  (eq? "abc" "abc") => unspecified
  (let ([x "hi"]) (eq? x x)) => #t
  (let ([x (string #\h #\i)]) (eq? x x)) => #t
  (eq? (string #\h #\i)
       (string #\h #\i)) => #f

  (eq? '#vu8(1) '#vu8(1)) => unspecified
  (eq? '#vu8(1) '#vu8(2)) => #f
  (let ([x (make-bytevector 10 0)])
    (eq? x x)) => #t
  (let ([x (make-bytevector 10 0)])
    (eq? x (make-bytevector 10 0))) => #f

  (eq? '#(a) '#(b)) => #f
  (eq? '#(a) '#(a)) => unspecified
  (let ([x '#(a)]) (eq? x x)) => #t
  (let ([x (vector 'a)])
    (eq? x x)) => #t
  (eq? (vector 'a) (vector 'a)) => #f

  (eq? car car) => #t
  (eq? car cdr) => #f
  (let ([f (lambda (x) x)])
    (eq? f f)) => #t
  (let ([f (lambda () (lambda (x) x))])
    (eq? (f) (f))) => unspecified
  (eq? (lambda (x) x) (lambda (y) y)) => unspecified

  (let ([f (lambda (x)
             (lambda ()
               (set! x (+ x 1))
               x))])
    (eq? (f 0) (f 0))) => #f
#+END_SRC


procedure: ~(eqv? obj1 obj2)~

返回: 如果 ~obj1~ 和 ~obj2~ 相等，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


eqv? 类似于 eq?, 只是 eqv? 对以下情况确定返回 #t: 被 char=? 判定为相等的两个字符，被 = 判定为相等 (a)，且不能被 eq? 和 eqv? 以外的任何操作区分 (b) 的两个数字。(b) 的一个推论是，在区分 -0.0 和+0.0 的系统中（比如那些基于 IEEE 浮点算术的系统），虽然 (= -0.0 +0.0) 为 #t, 但 (eqv? -0.0 +0.0) 为 #f. 这是因为一些操作，比如 /， 可以揭示出它们之间区别：

#+BEGIN_SRC scheme
  (/ 1.0 -0.0) => -inf.0
  (/ 1.0 +0.0) => +inf.0
#+END_SRC

类似的，虽然 3.0 和 3.0+0.0i 在数值上被认为是相等的，但如果 -0.0 和 0.0 为不同的表示形式，则 eqv? 会判定它们为不相等。

#+BEGIN_SRC scheme
  (= 3.0+0.0i 3.0) => #t
  (eqv? 3.0+0.0i 3.0) => #f
#+END_SRC

实参为 NaNs 时，eqv?返回的布尔值是未定义的。

~(eqv? +nan.0 (/ 0.0 0.0)) => unspecified~

eqv? 比起 eq?, 对具体实现的依赖较少，但通常对资源的消耗更大。

#+BEGIN_SRC scheme
  (eqv? 'a 3) => #f
  (eqv? #t 't) => #f
  (eqv? "abc" 'abc) => #f
  (eqv? "hi" '(hi)) => #f
  (eqv? #f '()) => #f

  (eqv? 9/2 7/2) => #f
  (eqv? 3.4 53344) => #f
  (eqv? 3 3.0) => #f
  (eqv? 1/3 #i1/3) => #f

  (eqv? 9/2 9/2) => #t
  (eqv? 3.4 (+ 3.0 .4)) => #t
  (let ([x (* 12345678987654321 2)])
    (eqv? x x)) => #t

  (eqv? #\a #\b) => #f
  (eqv? #\a #\a) => #t
  (let ([x (string-ref "hi" 0)])
    (eqv? x x)) => #t

  (eqv? #t #t) => #t
  (eqv? #f #f) => #t
  (eqv? #t #f) => #f
  (eqv? (null? '()) #t) => #t
  (eqv? (null? '(a)) #f) => #t

  (eqv? (cdr '(a)) '()) => #t

  (eqv? 'a 'a) => #t
  (eqv? 'a 'b) => #f
  (eqv? 'a (string->symbol "a")) => #t

  (eqv? '(a) '(b)) => #f
  (eqv? '(a) '(a)) => unspecified
  (let ([x '(a . b)]) (eqv? x x)) => #t
  (let ([x (cons 'a 'b)])
    (eqv? x x)) => #t
  (eqv? (cons 'a 'b) (cons 'a 'b)) => #f

  (eqv? "abc" "cba") => #f
  (eqv? "abc" "abc") => unspecified
  (let ([x "hi"]) (eqv? x x)) => #t
  (let ([x (string #\h #\i)]) (eqv? x x)) => #t
  (eqv? (string #\h #\i)
        (string #\h #\i)) => #f

  (eqv? '#vu8(1) '#vu8(1)) => unspecified
  (eqv? '#vu8(1) '#vu8(2)) => #f
  (let ([x (make-bytevector 10 0)])
    (eqv? x x)) => #t
  (let ([x (make-bytevector 10 0)])
    (eqv? x (make-bytevector 10 0))) => #f

  (eqv? '#(a) '#(b)) => #f
  (eqv? '#(a) '#(a)) => unspecified
  (let ([x '#(a)]) (eqv? x x)) => #t
  (let ([x (vector 'a)])
    (eqv? x x)) => #t
  (eqv? (vector 'a) (vector 'a)) => #f

  (eqv? car car) => #t
  (eqv? car cdr) => #f
  (let ([f (lambda (x) x)])
    (eqv? f f)) => #t
  (let ([f (lambda () (lambda (x) x))])
    (eqv? (f) (f))) => unspecified
  (eqv? (lambda (x) x) (lambda (y) y)) => unspecified

  (let ([f (lambda (x)
             (lambda ()
               (set! x (+ x 1))
               x))])
    (eqv? (f 0) (f 0))) => #f
#+END_SRC


procedure: ~(equal? obj1 obj2)~

返回: 如果 ~obj1~ 和 ~obj2~ 具有相同的结构和内容，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


如果两个对象基于 eqv? 判定是相等的，则它们是 equal 的，如 string=? 的字符串，bytevector=? 的字节向量，cars 和 cdrs 都相等的点对，或相同长度，且对应元素都相等的向量。

equal? is required to terminate even for cyclic arguments 和 return #t "if 和 only if the (possibly infinite) unfoldings of its arguments into regular trees are equal as ordered trees" [24]. In essence, two values are equivalent, in the sense of equal?, if the structure of the two objects cannot be distinguished by any composition of pair 和 vector accessors along with the eqv?, string=?, 和 bytevector=? procedures for comparing data at the leaves.

如何高效实现 equal? 是很棘手的，而即使在一个很好的实现中，它也很可能比 eqv? 或 eq? 更消耗资源。

#+BEGIN_SRC scheme
  (equal? 'a 3) => #f
  (equal? #t 't) => #f
  (equal? "abc" 'abc) => #f
  (equal? "hi" '(hi)) => #f
  (equal? #f '()) => #f

  (equal? 9/2 7/2) => #f
  (equal? 3.4 53344) => #f
  (equal? 3 3.0) => #f
  (equal? 1/3 #i1/3) => #f

  (equal? 9/2 9/2) => #t
  (equal? 3.4 (+ 3.0 .4)) => #t
  (let ([x (* 12345678987654321 2)])
    (equal? x x)) => #t

  (equal? #\a #\b) => #f
  (equal? #\a #\a) => #t
  (let ([x (string-ref "hi" 0)])
    (equal? x x)) => #t

  (equal? #t #t) => #t
  (equal? #f #f) => #t
  (equal? #t #f) => #f
  (equal? (null? '()) #t) => #t
  (equal? (null? '(a)) #f) => #t

  (equal? (cdr '(a)) '()) => #t

  (equal? 'a 'a) => #t
  (equal? 'a 'b) => #f
  (equal? 'a (string->symbol "a")) => #t

  (equal? '(a) '(b)) => #f
  (equal? '(a) '(a)) => #t
  (let ([x '(a . b)]) (equal? x x)) => #t
  (let ([x (cons 'a 'b)])
    (equal? x x)) => #t
  (equal? (cons 'a 'b) (cons 'a 'b)) => #t

  (equal? "abc" "cba") => #f
  (equal? "abc" "abc") => #t
  (let ([x "hi"]) (equal? x x)) => #t
  (let ([x (string #\h #\i)]) (equal? x x)) => #t
  (equal? (string #\h #\i)
          (string #\h #\i)) => #t

  (equal? '#vu8(1) '#vu8(1)) => #t
  (equal? '#vu8(1) '#vu8(2)) => #f
  (let ([x (make-bytevector 10 0)])
    (equal? x x)) => #t
  (let ([x (make-bytevector 10 0)])
    (equal? x (make-bytevector 10 0))) => #t

  (equal? '#(a) '#(b)) => #f
  (equal? '#(a) '#(a)) => #t
  (let ([x '#(a)]) (equal? x x)) => #t
  (let ([x (vector 'a)])
    (equal? x x)) => #t
  (equal? (vector 'a) (vector 'a)) => #t

  (equal? car car) => #t
  (equal? car cdr) => #f
  (let ([f (lambda (x) x)])
    (equal? f f)) => #t
  (let ([f (lambda () (lambda (x) x))])
    (equal? (f) (f))) => unspecified
  (equal? (lambda (x) x) (lambda (y) y)) => unspecified

  (let ([f (lambda (x)
             (lambda ()
               (set! x (+ x 1))
               x))])
    (equal? (f 0) (f 0))) => #f

  (equal?
    (let ([x (cons 'x 'x)])
      (set-car! x x)
      (set-cdr! x x)
      x)
    (let ([x (cons 'x 'x)])
      (set-car! x x)
      (set-cdr! x x)
      (cons x x))) => #t
#+END_SRC


procedure: ~(boolean? obj)~

返回: 如果 ~obj~ 是 #t 或 #f，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


boolean? 等价于 (lambda (x) (or (eq? x #t) (eq? x #f))).

#+BEGIN_SRC scheme
  (boolean? #t) => #t
  (boolean? #f) => #t
  (or (boolean? 't) (boolean? '())) => #f
#+END_SRC


procedure: ~(null? obj)~

返回: 如果 ~obj~ 是空列表，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


null? 等价于 (lambda (x) (eq? x '())).

#+BEGIN_SRC scheme
  (null? '()) => #t
  (null? '(a)) => #f
  (null? (cdr '(a))) => #t
  (null? 3) => #f
  (null? #f) => #f
#+END_SRC


procedure: ~(pair? obj)~

返回: 如果 ~obj~ 是点对，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (pair? '(a b c)) => #t
  (pair? '(3 . 4)) => #t
  (pair? '()) => #f
  (pair? '#(a b)) => #f
  (pair? 3) => #f
#+END_SRC


procedure: ~(number? obj)~

返回: 如果 ~obj~ 是数字对象，则为 ~#t~, 否则为 ~#f~.

procedure: ~(complex? obj)~

返回: 如果 ~obj~ 是复数对象，则为 ~#t~, 否则为 ~#f~.

procedure: ~(real? obj)~

返回: 如果 ~obj~ 是实数对象，则为 ~#t~, 否则为 ~#f~.

procedure: ~(rational? obj)~

返回: 如果 ~obj~ 是有理数对象，则为 ~#t~, 否则为 ~#f~.

procedure: ~(integer? obj)~

返回: 如果 ~obj~ 是整数对象，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


这些谓词形成了一个层次结构：任何整数都是有理数，任何有理数都是实数，任何实数都是复数，而任何复数都是数字。大多数实现不提供无理数的内部表示，所以所有实数通常也是有理数。

对于以不精确的 0 为虚部的复数，谓词 real?, rational?, 和 integer? 不会把它识别为实数，有理数或整数。

#+BEGIN_SRC scheme
  (integer? 1901) => #t
  (rational? 1901) => #t
  (real? 1901) => #t
  (complex? 1901) => #t
  (number? 1901) => #t

  (integer? -3.0) => #t
  (rational? -3.0) => #t
  (real? -3.0) => #t
  (complex? -3.0) => #t
  (number? -3.0) => #t

  (integer? 7+0i) => #t
  (rational? 7+0i) => #t
  (real? 7+0i) => #t
  (complex? 7+0i) => #t
  (number? 7+0i) => #t

  (integer? -2/3) => #f
  (rational? -2/3) => #t
  (real? -2/3) => #t
  (complex? -2/3) => #t
  (number? -2/3) => #t

  (integer? -2.345) => #f
  (rational? -2.345) => #t
  (real? -2.345) => #t
  (complex? -2.345) => #t
  (number? -2.345) => #t

  (integer? 7.0+0.0i) => #f
  (rational? 7.0+0.0i) => #f
  (real? 7.0+0.0i) => #f
  (complex? 7.0+0.0i) => #t
  (number? 7.0+0.0i) => #t

  (integer? 3.2-2.01i) => #f
  (rational? 3.2-2.01i) => #f
  (real? 3.2-2.01i) => #f
  (complex? 3.2-2.01i) => #t
  (number? 3.2-2.01i) => #t

  (integer? 'a) => #f
  (rational? '(a b c)) => #f
  (real? "3") => #f
  (complex? '#(1 2)) => #f
  (number? #\a) => #f
#+END_SRC


procedure: ~(real-valued? obj)~

返回: 如果 ~obj~ 是实数，则为 ~#t~, 否则为 ~#f~.

procedure: ~(rational-valued? obj)~

返回: 如果 ~obj~ 是有理数，则为 ~#t~, 否则为 ~#f~.

procedure: ~(integer-valued? obj)~

返回: 如果 ~obj~ 是整数，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


这些谓词类似于 real?, rational?, 和 integer?, 但把以不精确的 0 为虚部的复数当作实数，有理数或整数。

#+BEGIN_SRC scheme
  (integer-valued? 1901) => #t
  (rational-valued? 1901) => #t
  (real-valued? 1901) => #t

  (integer-valued? -3.0) => #t
  (rational-valued? -3.0) => #t
  (real-valued? -3.0) => #t

  (integer-valued? 7+0i) => #t
  (rational-valued? 7+0i) => #t
  (real-valued? 7+0i) => #t

  (integer-valued? -2/3) => #f
  (rational-valued? -2/3) => #t
  (real-valued? -2/3) => #t

  (integer-valued? -2.345) => #f
  (rational-valued? -2.345) => #t
  (real-valued? -2.345) => #t

  (integer-valued? 7.0+0.0i) => #t
  (rational-valued? 7.0+0.0i) => #t
  (real-valued? 7.0+0.0i) => #t

  (integer-valued? 3.2-2.01i) => #f
  (rational-valued? 3.2-2.01i) => #f
  (real-valued? 3.2-2.01i) => #f
#+END_SRC


和 real?, rational?, 及 integer? 一样，这些谓词对所有非数字值返回 #f.

#+BEGIN_SRC scheme
  (integer-valued? 'a) => #f
  (rational-valued? '(a b c)) => #f
  (real-valued? "3") => #f
#+END_SRC


procedure: ~(char? obj)~

返回: 如果 ~obj~ 是字符，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (char? 'a) => #f
  (char? 97) => #f
  (char? #\a) => #t
  (char? "a") => #f
  (char? (string-ref (make-string 1) 0)) => #t
#+END_SRC


procedure: ~(string? obj)~

返回: 如果 ~obj~ 是字符串，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (string? "hi") => #t
  (string? 'hi) => #f
  (string? #\h) => #f
#+END_SRC


procedure: ~(vector? obj)~

返回: 如果 ~obj~ 是向量，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (vector? '#()) => #t
  (vector? '#(a b c)) => #t
  (vector? (vector 'a 'b 'c)) => #t
  (vector? '()) => #f
  (vector? '(a b c)) => #f
  (vector? "abc") => #f
#+END_SRC


procedure: ~(symbol? obj)~

返回: 如果 ~obj~ 是符号，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (symbol? 't) => #t
  (symbol? "t") => #f
  (symbol? '(t)) => #f
  (symbol? #\t) => #f
  (symbol? 3) => #f
  (symbol? #t) => #f
#+END_SRC


procedure: ~(procedure? obj)~

返回: 如果 ~obj~ 是过程，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


#+BEGIN_SRC scheme
  (procedure? car) => #t
  (procedure? 'car) => #f
  (procedure? (lambda (x) x)) => #t
  (procedure? '(lambda (x) x)) => #f
  (call/cc procedure?) => #t
#+END_SRC


procedure: ~(bytevector? obj)~

返回: 如果 ~obj~ 是字节向量，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs bytevectors), (rnrs)


#+BEGIN_SRC scheme
  (bytevector? #vu8()) => #t
  (bytevector? '#()) => #f
  (bytevector? "abc") => #f
#+END_SRC


procedure: ~(hashtable? obj)~

返回: 如果 ~obj~ 是哈希表，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs hashtables), (rnrs)


#+BEGIN_SRC scheme
  (hashtable? (make-eq-hashtable)) => #t
  (hashtable? '(not a hash table)) => #f
#+END_SRC


** Section 6.3. 列表和点对

点对，或结构单元，是 Scheme 结构化对象类型的基础。点对最常见的用法是构造列表，列表是点对的有序序列，通过 cdr 字段一个接一个链接起来。列表的元素占据点对的 car 字段。在一个完全列表中，最后一个点对的 cdr 字段是空列表，(); 在一个不完全列表中，最后一个点对的 cdr 字段可以是除()以外的任何对象。

点对可用于构造二叉树。树结构中的每个点对是二叉树中的一个内部节点；它的 car 和 cdr 是节点的子节点。

完全列表打印为圆括号中由空白隔开的对象序列。匹配的方括号( [ ] )可用于替代圆括号。例如， (1 2 3) 和 (a [nested list]) 是完全列表。空列表写作 ().

不完全列表和树需要稍复杂一些的语法。一个单独的点对写作由空白和一个点分隔的两个对象，例如，(a . b). 这被称为点对记法。不完全列表和树也以点对记法书写；点在需要的时候显示，例如，(1 2 3 . 4) 或 ((1 . 2) . 3). 完全列表也可以写作点对的形式。例如， (1 2 3) 也可以写作 (1 . (2 . (3 . ()))).

通过使用 set-car! 或 set-cdr! 破坏性地更改点对的 car 或 cdr 字段，可以创造循环列表或环状图。这类列表不是完全列表。

Procedures that accept a list argument are required to detect that the list is improper only to the extent that they actually traverse the list far enough either (a) to attempt to operate on a non-list tail or (b) to loop indefinitely due to a circularity. For example, member need not detect that a list is improper if it actually finds the element being sought, 和 list-ref need never detect circularities, because its recursion is bounded by the index argument.
接受一个列表实参的过程，只在下列情况下需要检查列表是否是不完全的：它们对列表的遍历足够深，(a) 尝试操作一个非列表的尾部，或 (b) 基于环进行无限循环。例如，如果 member 找到了要找的元素，则它不需要检查列表是否是不完全的，而 list-ref 永远不需要检测列表是否为环，因为它的递归已经通过实参 index 限定了边界。


procedure: ~(cons obj1 obj2)~

returns: 一个新的点对，它的 car 和 cdr 是 obj1 和 obj2

libraries: (rnrs base), (rnrs)


cons 是点对构造过程。obj1 成为新点对的 car， 而 obj2 成为新点对的 cdr.

#+BEGIN_SRC scheme
  (cons 'a '()) => (a)
  (cons 'a '(b c)) => (a b c)
  (cons 3 4) => (3 . 4)
#+END_SRC


procedure: ~(car pair)~

returns: 点对的 car

libraries: (rnrs base), (rnrs)


空列表不是点对，所以实参不能是空列表。

#+BEGIN_SRC scheme
  (car '(a)) => a
  (car '(a b c)) => a
  (car (cons 3 4)) => 3
#+END_SRC


procedure: ~(cdr pair)~

returns: 点对的 cdr

libraries: (rnrs base), (rnrs)


空列表不是点对，所以实参不能是空列表。

#+BEGIN_SRC scheme
  (cdr '(a)) => ()
  (cdr '(a b c)) => (b c)
  (cdr (cons 3 4)) => 4
#+END_SRC


procedure: ~(set-car! pair obj)~

returns: unspecified

libraries: (rnrs mutable-pairs)


set-car! 把点对的 car 更改为 obj.

#+BEGIN_SRC scheme
  (let ([x (list 'a 'b 'c)])
    (set-car! x 1)
    x) => (1 b c)
#+END_SRC


procedure: ~(set-cdr! pair obj)~

returns: unspecified

libraries: (rnrs mutable-pairs)


set-cdr! 把点对的 cdr 更改为 obj.

#+BEGIN_SRC scheme
  (let ([x (list 'a 'b 'c)])
    (set-cdr! x 1)
    x) => (a . 1)
#+END_SRC


procedure: ~(caar pair)~

procedure: ~(cadr pair)~ =>

procedure: ~(cddddr pair)~

returns: 点对的 caar, cadr, ..., 或 cddddr

libraries: (rnrs base), (rnrs)


这些过程以至多四个 cars 和 cdrs 的组合定义。c 和 r 之间的 a 和 d 代表了对 car 或 cdr 的调用，顺序为从右到左。例如，应用于一个点对的过程 cadr，返回点对的 cdr 的 car，其等价于 (lambda (x) (car (cdr x))).

#+BEGIN_SRC scheme
  (caar '((a))) => a
  (cadr '(a b c)) => b
  (cdddr '(a b c d)) => (d)
  (cadadr '(a (b c))) => c
#+END_SRC


procedure: ~(list obj ...)~

returns: obj ... 组成的列表

libraries: (rnrs base), (rnrs)


list 等价于 (lambda x x).

#+BEGIN_SRC scheme
  (list) => ()
  (list 1 2 3) => (1 2 3)
  (list 3 2 1) => (3 2 1)
#+END_SRC


procedure: ~(cons* obj ... final-obj)~

returns: obj ... 组成的列表，以 final-obj 结束

libraries: (rnrs lists), (rnrs)


If the objects obj ... are omitted, the result is simply final-obj. Otherwise, a list of obj ... is constructed, as with list, except that the final cdr field is final-obj instead of (). If final-obj is not a list, the result is an improper list.
如果省略 obj ..., 则结果就是 final-obj. 不然，就和 list 一样，构造出一个 obj ... 组成的列表，只是最后的 cdr 字段由 final-obj 替代了 (). 如果 final-obj 不是列表，则结果是一个不完全列表。

#+BEGIN_SRC scheme
  (cons* '()) => ()
  (cons* '(a b)) => (a b)
  (cons* 'a 'b 'c) => (a b . c)
  (cons* 'a 'b '(c d)) => (a b c d)
#+END_SRC


procedure: ~(list? obj)~

返回: 如果 ~obj~ 是完全列表，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)


对于所有不完全列表，list? 一定返回 #f, 包括环状列表。list? 的定义参见第 67 页。

#+BEGIN_SRC scheme
  (list? '()) => #t
  (list? '(a b c)) => #t
  (list? 'a) => #f
  (list? '(3 . 4)) => #f
  (list? 3) => #f
  (let ([x (list 'a 'b 'c)])
    (set-cdr! (cddr x) x)
    (list? x)) => #f
#+END_SRC


procedure: ~(length list)~

returns: list 中的元素数量

libraries: (rnrs base), (rnrs)


length 可依如下定义，使用 67 页定义 list? 的龟兔赛跑算法的适配版本。

#+BEGIN_SRC scheme
  (define length
    (lambda (x)
      (define improper-list
        (lambda ()
          (assertion-violation 'length "not a proper list" x)))

      (let f ([h x] [t x] [n 0])
        (if (pair? h)
            (let ([h (cdr h)])
              (if (pair? h)
                  (if (eq? h t)
                      (improper-list)
                      (f (cdr h) (cdr t) (+ n 2)))
                  (if (null? h)
                      (+ n 1)
                      (improper-list))))
            (if (null? h)
                n
                (improper-list))))))

  (length '()) => 0
  (length '(a b c)) => 3
  (length '(a b . c)) => exception
  (length
   (let ([ls (list 'a 'b)])
     (set-cdr! (cdr ls) ls) => exception
     ls))
  (length
   (let ([ls (list 'a 'b)])
     (set-car! (cdr ls) ls) => 2
     ls))
#+END_SRC


procedure: ~(list-ref list n)~

returns: list 的第 n 个元素（基于 0）

libraries: (rnrs base), (rnrs)


n 必须是精确的非负整数，且小于 list 的长度。不带有错误检查的 list-ref 可以定义如下。

#+BEGIN_SRC scheme
  (define list-ref
    (lambda (ls n)
      (if (= n 0)
          (car ls)
          (list-ref (cdr ls) (- n 1)))))

  (list-ref '(a b c) 0) => a
  (list-ref '(a b c) 1) => b
  (list-ref '(a b c) 2) => c
#+END_SRC


procedure: ~(list-tail list n)~

returns: list 的第 n 个尾部（基于 0）

libraries: (rnrs base), (rnrs)


n 必须是精确的非负整数，且小于等于 list 的长度。结果不是拷贝；返回的尾部 eq? 于 list 的第 n 个 cdr（或 list 本身，如果 n 为 0）。

不带有错误检查的 list-tail 可以定义如下。

#+BEGIN_SRC scheme
  (define list-tail
    (lambda (ls n)
      (if (= n 0)
          ls
          (list-tail (cdr ls) (- n 1)))))

  (list-tail '(a b c) 0) => (a b c)
  (list-tail '(a b c) 2) => (c)
  (list-tail '(a b c) 3) => ()
  (list-tail '(a b c . d) 2) => (c . d)
  (list-tail '(a b c . d) 3) => d
  (let ([x (list 1 2 3)])
    (eq? (list-tail x 2)
         (cddr x))) => #t
#+END_SRC


procedure: ~(append)~

procedure: ~(append list ... obj)~

returns: 输入列表的串联

libraries: (rnrs base), (rnrs)


append 返回一个新的列表，其中元素依次为：第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。对于所有实参，新列表由新生成的点对构成，除了最后一个实参；最后一个实参（不必是列表）被直接放置于新结构的末尾。不带有错误检查的的 append 可以定义如下。

#+BEGIN_SRC scheme
  (define append
    (lambda args
      (let f ([ls '()] [args args])
        (if (null? args)
            ls
            (let g ([ls ls])
              (if (null? ls)
                  (f (car args) (cdr args))
                  (cons (car ls) (g (cdr ls)))))))))

  (append '(a b c) '()) => (a b c)
  (append '() '(a b c)) => (a b c)
  (append '(a b) '(c d)) => (a b c d)
  (append '(a b) 'c) => (a b . c)
  (let ([x (list 'b)])
    (eq? x (cdr (append '(a) x)))) => #t
#+END_SRC


procedure: ~(reverse list)~

returns: list 中的元素逆向排序后组成的新列表

libraries: (rnrs base), (rnrs)


不带有错误检查的 reverse 可以定义如下。

#+BEGIN_SRC scheme
  (define reverse
    (lambda (ls)
      (let rev ([ls ls] [new '()])
        (if (null? ls)
            new
            (rev (cdr ls) (cons (car ls) new))))))

  (reverse '()) => ()
  (reverse '(a b c)) => (c b a)
#+END_SRC


procedure: ~(memq obj list)~

procedure: ~(memv obj list)~

procedure: ~(member obj list)~

returns: list 中第一个 car 等于 obj 的尾部，或 #f

libraries: (rnrs lists), (rnrs)


这些过程按顺序遍历实参 list, 比较 obj 和 list 中的元素。如果找到了等于 obj 的对象，则返回 list 中第一个元素为此对象的尾段。如果 list 中等于 obj 的对象多于 1 个，则返回第一个首元素等于 obj 的尾段。如果没有找到等于 obj 的对象，则返回#f. memq 的相等性测试使用 eq?, memv 使用 eqv?, 而 member 使用 equal?.

这些过程最常用作谓词，但它们的名字不以问题结尾，因为它们返回一个有用的真值，而不是#t. 不带有错误检查的 memq 可以定义如下。

#+BEGIN_SRC scheme
  (define memq
    (lambda (x ls)
      (cond
       [(null? ls) #f]
       [(eq? (car ls) x) ls]
       [else (memq x (cdr ls))])))
#+END_SRC


memv 和 member 的定义类似，分别以 eqv? 和 equal? 替换 eq?.

#+BEGIN_SRC scheme
  (memq 'a '(b c a d e)) => (a d e)
  (memq 'a '(b c d e g)) => #f
  (memq 'a '(b a c a d a)) => (a c a d a)

  (memv 3.4 '(1.2 2.3 3.4 4.5)) => (3.4 4.5)
  (memv 3.4 '(1.3 2.5 3.7 4.9)) => #f
  (let ([ls (list 'a 'b 'c)])
    (set-car! (memv 'b ls) 'z)
    ls) => (a z c)

  (member '(b) '((a) (b) (c))) => ((b) (c))
  (member '(d) '((a) (b) (c))) => #f
  (member "b" '("a" "b" "c")) => ("b" "c")

  (let ()
    (define member?
      (lambda (x ls)
        (and (member x ls) #t)))
    (member? '(b) '((a) (b) (c)))) => #t

  (define count-occurrences
    (lambda (x ls)
      (cond
       [(memq x ls) =>
        (lambda (ls)
          (+ (count-occurrences x (cdr ls)) 1))]
       [else 0])))

  (count-occurrences 'a '(a b c d a)) => 2
#+END_SRC


procedure: ~(memp procedure list)~

returns: list 中第一个其 car 字段传入 procedure 返回 #t 的尾段，或#f

libraries: (rnrs lists), (rnrs)


procedure should accept one argument 和 return a single value. It should not modify list.
procedure 应该接受 1 个实参，并返回一个单个值。它不应修改 list.

#+BEGIN_SRC scheme
  (memp odd? '(1 2 3 4)) => (1 2 3 4)
  (memp even? '(1 2 3 4)) => (2 3 4)
  (let ([ls (list 1 2 3 4)])
    (eq? (memp odd? ls) ls)) => #t
  (let ([ls (list 1 2 3 4)])
    (eq? (memp even? ls) (cdr ls))) => #t
  (memp odd? '(2 4 6 8)) => #f
#+END_SRC


procedure: ~(remq obj list)~

procedure: ~(remv obj list)~

procedure: ~(remove obj list)~

returns: list 中所有不等于 obj 的元素组成的列表

libraries: (rnrs lists), (rnrs)


这些过程遍历实参 list, 移除所有等于 obj 的对象。输出列表中保留的元素和它们在输入列表中出现的顺序一致。如果一个列表的尾段（包括列表自身）不包含任何 obj, 则结果列表中对应的尾段可能与输入列表中的相应尾段相同（基于 eq? 判断）。

remq 的相等性测试基于 eq?, remv 基于 eqv?, 而 remove 基于 equal?.

#+BEGIN_SRC scheme
  (remq 'a '(a b a c a d)) => (b c d)
  (remq 'a '(b c d)) => (b c d)

  (remv 1/2 '(1.2 1/2 0.5 3/2 4)) => (1.2 0.5 3/2 4)

  (remove '(b) '((a) (b) (c))) => ((a) (c))
#+END_SRC


procedure: ~(remp procedure list)~

returns: list 中应用 procedure 返回 #f 的元素组成的列表

libraries: (rnrs lists), (rnrs)


procedure 应该接受一个参数，并返回一个单个值。它不应修改 list.

remp 把 procedure 应用于列表中的每个元素，并返回一个列表，其中只包含使 procedure 返回 #f 的元素。返回列表中的元素与它们在原列表中出现的顺序是一致的。

#+BEGIN_SRC scheme
  (remp odd? '(1 2 3 4)) => (2 4)
  (remp
   (lambda (x) (and (> x 0) (< x 10)))
   '(-5 15 3 14 -20 6 0 -9)) => (-5 15 14 -20 0 -9)
#+END_SRC


procedure: ~(filter procedure list)~

returns: list 中应用 procedure 返回真值的元素组成的列表

libraries: (rnrs lists), (rnrs)


procedure 应该接受一个参数，并返回一个单个值。它不应修改 list.

filter 把 procedure 应用于列表中的每个元素，并返回一个列表，其中只包含使 procedure 返回真值的元素。返回列表中的元素与它们在原列表中出现的顺序是一致的。

#+BEGIN_SRC scheme
  (filter odd? '(1 2 3 4)) => (1 3)
  (filter
   (lambda (x) (and (> x 0) (< x 10)))
   '(-5 15 3 14 -20 6 0 -9)) => (3 6)
#+END_SRC


procedure: ~(partition procedure list)~

returns: 参见下文

libraries: (rnrs lists), (rnrs)


procedure 应该接受一个参数，并返回一个单个值。它不应修改 list.

partition 把 procedure 应用于列表中的每个元素，并返回两个值：一个只包含使 procedure 返回真值的元素组成的列表，和一个只包含使 procedure 返回 #f 的元素组成的列表。返回列表中的元素与它们在原列表中出现的顺序是一致的。

#+BEGIN_SRC scheme
  (partition odd? '(1 2 3 4)) => (1 3)
  (2 4)
  (partition
   (lambda (x) (and (> x 0) (< x 10)))
   '(-5 15 3 14 -20 6 0 -9)) => (3 6)
  (-5 15 14 -20 0 -9)
#+END_SRC

partition 返回的值也可以通过分别调用 filter 和 remp 得到，但这样需要对列表中的每个元素调用两次 procedure.


procedure: ~(find procedure list)~

returns: list 中使 procedure 返回真值的第一个元素，或 #f

libraries: (rnrs lists), (rnrs)


procedure 应该接受一个参数，并返回一个单个值。它不应修改 list.

find 依序遍历实参 list, 轮流对每个元素应用 procedure. 如果 procedure 对给定元素返回一个真值，则 find 返回此元素，并且不再对其它元素应用 procedure. 如果 procedure 对 list 中的每个元素都返回 #f, 则 find 返回 #f.

如果一个程序必须区分在 list 中找到的是 #f 还是找不到任何元素，则应该使用 memp.

#+BEGIN_SRC scheme
  (find odd? '(1 2 3 4)) => 1
  (find even? '(1 2 3 4)) => 2
  (find odd? '(2 4 6 8)) => #f
  (find not '(1 a #f 55)) => #f
#+END_SRC


procedure: ~(assq obj alist)~

procedure: ~(assv obj alist)~

procedure: ~(assoc obj alist)~

returns: alist 中 car 字段等于 obj 的第一个元素，或 #f

libraries: (rnrs lists), (rnrs)


实参 alist 必须是关联列表。关联列表是一种完全列表，其元素是形如 (key . value) 的键值对。在存储特定对象（键）及其相关的信息（值）时，关联列表很有用。

这些过程遍历关联列表，测试每个键与 obj 的相等性。如果找到一个相等的键，则返回此键值对。否则，返回 #f.

assq 的相等性测试基于 eq?, assv 基于 eqv?, 而 assoc 基于 equal?. 不带有错误检测的 assq 可以定义如下。

#+BEGIN_SRC scheme
  (define assq
    (lambda (x ls)
      (cond
       [(null? ls) #f]
       [(eq? (caar ls) x) (car ls)]
       [else (assq x (cdr ls))])))
#+END_SRC


assv 和 assoc 的定义类似，分别以 eqv? 和 equal? 替代 eq?.

#+BEGIN_SRC scheme
  (assq 'b '((a . 1) (b . 2))) => (b . 2)
  (cdr (assq 'b '((a . 1) (b . 2)))) => 2
  (assq 'c '((a . 1) (b . 2))) => #f

  (assv 2/3 '((1/3 . 1) (2/3 . 2))) => (2/3 . 2)
  (assv 2/3 '((1/3 . a) (3/4 . b))) => #f

  (assoc '(a) '(((a) . a) (-1 . b))) => ((a) . a)
  (assoc '(a) '(((b) . b) (a . c))) => #f

  (let ([alist (list (cons 2 'a) (cons 3 'b))])
    (set-cdr! (assv 3 alist) 'c)
    alist) => ((2 . a) (3 . c))
#+END_SRC

12.7 节给出的解释器把环境表示为关联列表，并把 assq 用于变量查找和赋值。


procedure: ~(assp procedure alist)~

returns: alist 中 car 字段值使 procedure 返回真值的第一个元素，或 #f

libraries: (rnrs lists), (rnrs)


alist 必须是关联列表。关联列表是一种完全列表，其元素是形如 (key . value) 的键值对。procedure 应当接受一个实参，并返回一个单个值。它不应修改 list.

#+BEGIN_SRC scheme
  (assp odd? '((1 . a) (2 . b))) => (1 . a)
  (assp even? '((1 . a) (2 . b))) => (2 . b)
  (let ([ls (list (cons 1 'a) (cons 2 'b))])
    (eq? (assp odd? ls) (car ls))) => #t
  (let ([ls (list (cons 1 'a) (cons 2 'b))])
    (eq? (assp even? ls) (cadr ls))) => #t
  (assp odd? '((2 . b))) => #f
#+END_SRC


procedure: ~(list-sort predicate list)~

returns: list 中的元素根据 predicate 排序后组成的列表

libraries: (rnrs sorting), (rnrs)


predicate 应当是个过程，它接受两个实参，并且，当它的第一个实参在排序后的列表中必须排在第二个实参之前时返回 #t. 即，如果 predicate 应用于两个元素 x 和 y, 且在输入列表中 x 排在 y 后面，它应该只在 x 应当于输出列表中排在 y 前面时返回真。如果满足这一限制，list-sort 就是执行稳定的排序，即，根据 predicate，两个元素只在必要时重新排序。它并不移除重复元素。这个过程至多会调用 predicate nlog^n 次，其中 n 是 list 的长度。

#+BEGIN_SRC scheme
  (list-sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)
  (list-sort > '(0.5 1/2)) => (0.5 1/2)
  (list-sort > '(1/2 0.5)) => (1/2 0.5)
  (list->string
   (list-sort char>?
              (string->list "hello"))) => "ollhe"
#+END_SRC


** Section 6.4. 数字

Scheme 数字可以被分类为整数，有理数，实数，或复数。这种分类是层次结构的，其中所有整数是有理数，所有有理数是实数，而所有实数是复数。6.2 节中介绍的谓词 integer?, rational?, real?, 以及 complex? 用于判定数字属于其中哪个类别。

Scheme 数字也可以被分类为精确的或不精确的——基于派生出数字的操作的特性，以及这些操作的输入。谓词 exact? 和 inexact? 可以被用于判定一个数字的精确性。Scheme 中，大多数对数字的操作会保留精确性：如果给出精确的操作数，则返回精确值，如果给出不精确的操作数，或给出精确与不精确操作数的组合，则返回不精确值。

精确整数和有理数的运算通常支持任意精度；整数或比值的分子分母的大小只受限于系统的存储空间。虽然也可以用其它表示形式，但不精确数通常表示为由主机硬件或系统软件支持的浮点数。复数通常表示为有序点对（实部，虚部），其中实部和虚部是精确整数，精确有理数，或浮点数。

Scheme 数字以一种很直接的方式书写，与常规没有多少不同。一个精确整数通常写为一个数字序列，前面带有一个可选的符号。例如，3, +19, -100000, 以及 208423089237489374, 都表示精确的整数。

有理数通常写作以斜线 (/) 分隔的两个数字序列，前面带有一个可选的符号。例如，3/4, -6/5, and 1/1208203823 都是精确的有理数。读取时，比值会被直接归约为最简形式，甚至可能归约为一个精确整数。

不精确的实数通常写作浮点数或科学记数法。浮点数记法由一个数字序列接着一个小数点再接着一个数字序列构成，前面带有一个可选的符号。科学计数法由一个可选的符号，一个数字序列，一个可选的小数点，接着另一个数字串，和一个指数构成；指数写作字母 e 后面跟着一个可选的符号和一个数字序列。例如，1.0 和 -200.0 是有效的不精确整数，而 1.5, 0.034, -10e-10 和 1.5e-5 是有效的不精确有理数。指数即是其前面数字所有乘以的 10 的幂次，所以 2e3 等价于 2000.0.

在使用浮点记法或科学记数法时，尾数宽度 |w 可能作为实数或复数的实部的后缀出现。尾数宽度 w 表示了数字表示形式的有效位数。尾数宽度默认为 53（标准化 IEEE 双精度浮点数的有效位数）或更多。对于非标准化的 IEEE 双精度浮点数，尾数宽度小于 53. 如果一个实现不能以指定的尾数宽度表示一个数字，在可能的情况下，它会采用至少达到要求的有效位数的表示形式，否则，它会使用它的最大尾数宽度的表示形式。

精确和不精确的实数，写作精确或不精确的整数或有理数；对于非有理数（即无理数），Scheme 没有预设的语法。

Complex numbers may be written in either rectangular or polar form. In rectangular form, a complex number is written as x+yi or x-yi, where x is an integer, rational, or real number and y is an unsigned integer, rational, or real number. The real part, x, may be omitted, in which case it is assumed to be zero. For example, 3+4i, 3.2-3/4i, +i, and -3e-5i are complex numbers written in rectangular form. In polar form, a complex number is written as x@y, where x and y are integer, rational, or real numbers. For example, 1.1@1.764 and -1@-1/2 are complex numbers written in polar form.
复数可以写作直角坐标或极坐标的形式。直角坐标形式中，复数写作 x+yi 或 x-yi, 其中 x 是整数，有理数或实数，y 是无符号整数，有理数，或实数。实部 x 可以省略，此时它被当作 0. 例如，3+4i, 3.2-3/4i, +i, and -3e-5i 是写作直角坐标形式的复数。极坐标形式中，复数写作 x@y, 其中 x 和 y 是整数，有理数，或实数。例如，1.1@1.764 and -1@-1/2 是写作极坐标形式的复数。

The syntaxes +inf.0 and -inf.0 represent inexact real numbers that represent positive and negative infinity. The syntaxes +nan.0 and -nan.0 represent an inexact "not-a-number" (NaN) value. Infinities may be produced by dividing inexact positive and negative values by inexact zero, and NaNs may also be produced by dividing inexact zero by inexact zero, among other ways.
表示不精确实数的语法形式 +inf.0 和 -inf.0 表示正、负无穷。语法形式 +nan.0 和 -nan.0 表示不精确的没有数值(NaN). 无穷值可以通过不精确的正数或负数除以不精确的 0 生成，而 NaNs 可以通过不精确的 0 除以不精确的 0 生成，此外还有其它一些方法。

The exactness of a numeric representation may be overridden by preceding the representation by either #e or #i. #e forces the number to be exact, and #i forces it to be inexact. For example, 1, #e1, 1/1, #e1/1, #e1.0, and #e1e0 all represent the exact integer 1, and #i3/10, 0.3, #i0.3, and 3e-1 all represent the inexact rational 0.3.
通过在表示形式前添加 #e 或 #i, 可以重载数字表示形式的精确性。#e 强制数字为精确的，而#i 强制数字为不精确的。例如，1, #e1, 1/1, #e1/1, #e1.0, 以及 #e1e0 都表示精确整数 1, 而 #i3/10, 0.3, #i0.3, 以及 3e-1 都表示不精确的有理数 0.3.

数字默认以基数 10 书写，但是可以使用特定的前缀 #b (二进制), #o (八进制), #d (十进制), and #x (十六进制)指定基数 2，8，10，或 16.对于基数 16，字母 a 至 f 或 A 至 F 作为额外需要的数字以表达数位值 10 至 15。例如， #b10101 是 21_10 的等价二进制数, #o72 是 58_10 的等价八进制数，#xC7 是 199_10 的等价十六进制数。写作浮点数或科学记数法总是采用基数 10.

基数和精确性前缀同时使用时，可以以任何顺序出现。

A Scheme implementation may support more than one size of internal representation for inexact quantities. The exponent markers s (short), f (single), d (double), and l (long) may appear in place of the default exponent marker e to override the default size for numbers written in scientific notation. In implementations that support multiple representations, the default size has at least as much precision as double.
一个 Scheme 实现对于不精确数值的内部表示，可能支持不只一种精度。在科学记数法中，指数标记 s (短), f (单), d (双), 以及 l (长)可以替代默认的指数标记 e，以覆盖数字的默认精度。在支持多种表示形式的实现中，默认精度至少为双精度。

第 459 页给出了 Scheme 数字的精确语法。

Any number can be written in a variety of different ways, but the system printer (invoked by put-datum, write, and display) and number->string express numbers in a compact form, using the fewest number of digits necessary to retain the property that, when read, the printed number is identical to the original number.
所有数字都可以写作多种不同的形式，但是系统打印器（通过 put-datum, write, 以及 display 调用）和 number->string 以一种紧凑的形式表示数字，使用能够保持属性所必要的最少数位——在读取时，打印出的数字与原数字是一样的。

The remainder of this section describes "generic arithmetic" procedures that operate on numbers. The two sections that follow this section describe operations specific to fixnums and flonums, which are representations of exact, fixed-precision integer values and inexact real values.
本节的剩余部分介绍了数字操作的“通用算术”过程。之后的两节介绍了专用于 fixnums 和 flonums 的操作，此两者分别表示精确的固定精度整数值和不精确的实数。

本节中的过程所接受的数字实参类型，由参数名暗示：num 意指复数（即，所有数字），real 意指实数，rat 意指有理数，而 int 意指整数。如果需要的是 real, rat 或 int, 则实参必须是 real?, rational?, 或 integer? 所判定的实数，有理数，或整数，即，数字的虚部必须是精确的 0. 在需要精确整数的场合，会使用名字 exint. 在每种情况下，名字后面都可能会有后缀，如，int2.

procedure: ~(exact? num)~

返回: 如果 num 是精确的，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (exact? 1) => #t
  (exact? -15/16) => #t
  (exact? 2.01) => #f
  (exact? #i77) => #f
  (exact? #i2/3) => #f
  (exact? 1.0-2i) => #f
#+END_SRC

procedure: ~(inexact? num)~

返回: 如果 num 是不精确的，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (inexact? -123) => #f
  (inexact? #i123) => #t
  (inexact? 1e23) => #t
  (inexact? +i) => #f
#+END_SRC

procedure: ~(= num1 num2 num3 ...)~

procedure: ~(< real1 real2 real3 ...)~

procedure: ~(> real1 real2 real3 ...)~

procedure: ~(<= real1 real2 real3 ...)~

procedure: ~(>= real1 real2 real3 ...)~

返回: 如果关系成立，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

The predicate = returns #t if its arguments are equal. The predicate < returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while > returns #t if its arguments are monotonically decreasing. The predicate <= returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while >= returns #t if its arguments are monotonically nonincreasing.
谓词 =在其实参相等时返回#t。谓词 <在其实参单调递增时返回#t，即，每个实参都大于它前一个实参，而 >在其实参单调递减时返回#t。谓词 <=在其实参单调非递减时返回#t，即，每个实参不小于它前一个实参，而 >=在其实参单调非递增时返回#t。只传入一个实参时，这些谓词均返回#t。

如同参数名所暗示的， = 定义为接受复数实参，而其它关系谓词则定义为只接受实数实参。若两个复数的实部和虚部均相等，则它们被判定为相等。涉及 NaNs 的比较均返回 #f.

#+BEGIN_SRC scheme
  (= 7 7) => #t
  (= 7 9) => #f

  (< 2e3 3e2) => #f
  (<= 1 2 3 3 4 5) => #t
  (<= 1 2 3 4 5) => #t

  (> 1 2 2 3 3 4) => #f
  (>= 1 2 2 3 3 4) => #f

  (= -1/2 -0.5) => #t
  (= 2/3 .667) => #f
  (= 7.2+0i 7.2) => #t
  (= 7.2-3i 7) => #f

  (< 1/2 2/3 3/4) => #t
  (> 8 4.102 2/3 -5) => #t

  (let ([x 0.218723452])
    (< 0.210 x 0.220)) => #t

  (let ([i 1] [v (vector 'a 'b 'c)])
    (< -1 i (vector-length v))) => #t

  (apply < '(1 2 3 4)) => #t
  (apply > '(4 3 3 2)) => #f

  (= +nan.0 +nan.0) => #f
  (< +nan.0 +nan.0) => #f
  (> +nan.0 +nan.0) => #f
  (>= +inf.0 +nan.0) => #f
  (>= +nan.0 -inf.0) => #f
  (> +nan.0 0.0) => #f
#+END_SRC

procedure: ~(+ num ...)~

returns: 实参 num ... 的和

libraries: (rnrs base), (rnrs)

不带实参调用时， + 返回 0.

#+BEGIN_SRC scheme
  (+) => 0
  (+ 1 2) => 3
  (+ 1/2 2/3) => 7/6
  (+ 3 4 5) => 12
  (+ 3.0 4) => 7.0
  (+ 3+4i 4+3i) => 7+7i
  (apply + '(1 2 3 4 5)) => 15
#+END_SRC

procedure: ~(- num)~

returns: num 的加法逆元

procedure: ~(- num1 num2 num3 ...)~

returns: num1 与 num2 num3 ... 之和的差

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (- 3) => -3
  (- -2/3) => 2/3
  (- 4 3.0) => 1.0
  (- 3.25+4.25i 1/4+1/4i) => 3.0+4.0i
  (- 4 3 2 1) => -2
#+END_SRC

procedure: ~(* num ...)~

returns: num ... 的积

libraries: (rnrs base), (rnrs)

不带实参调用时， * 返回 1.

#+BEGIN_SRC scheme
  (*) => 1
  (* 3.4) => 3.4
  (* 1 1/2) => 1/2
  (* 3 4 5.5) => 66.0
  (* 1+2i 3+4i) => -5+10i
  (apply * '(1 2 3 4 5)) => 120
#+END_SRC

procedure: ~(/ num)~

returns: num 的乘法逆元

procedure: ~(/ num1 num2 num3 ...)~

returns: num1 除以 num2 num3 ... 之积的结果

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (/ -17) => -1/17
  (/ 1/2) => 2
  (/ .5) => 2.0
  (/ 3 4) => 3/4
  (/ 3.0 4) => .75
  (/ -5+10i 3+4i) => 1+2i
  (/ 60 5 4 3 2) => 1/2
#+END_SRC

procedure: ~(zero? num)~

返回: 如果 num 为 0，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

zero? 等价于 (lambda (x) (= x 0)).

#+BEGIN_SRC scheme
  (zero? 0) => #t
  (zero? 1) => #f
  (zero? (- 3.0 3.0)) => #t
  (zero? (+ 1/2 1/2)) => #f
  (zero? 0+0i) => #t
  (zero? 0.0-0.0i) => #t
#+END_SRC

procedure: ~(positive? real)~

返回: 如果 real 大于 0，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

positive? 等价于 (lambda (x) (> x 0)).

#+BEGIN_SRC scheme
  (positive? 128) => #t
  (positive? 0.0) => #f
  (positive? 1.8e-15) => #t
  (positive? -2/3) => #f
  (positive? .001-0.0i) => exception: not a real number
#+END_SRC

procedure: ~(negative? real)~

返回: 如果 real 小于 0，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

negative? 等价于 (lambda (x) (< x 0)).

#+BEGIN_SRC scheme
  (negative? -65) => #t
  (negative? 0) => #f
  (negative? -0.0121) => #t
  (negative? 15/16) => #f
  (negative? -7.0+0.0i) => exception: not a real number
#+END_SRC

procedure: ~(even? int)~

返回: 如果 int 是偶数，则为 ~#t~, 否则为 ~#f~.

procedure: ~(odd? int)~

返回: 如果 int 是奇数，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (even? 0) => #t
  (even? 1) => #f
  (even? 2.0) => #t
  (even? -120762398465) => #f
  (even? 2.0+0.0i) => exception: not an integer

  (odd? 0) => #f
  (odd? 1) => #t
  (odd? 2.0) => #f
  (odd? -120762398465) => #t
  (odd? 2.0+0.0i) => exception: not an integer
#+END_SRC

procedure: ~(finite? real)~

返回: 如果 ~real~ 是有限值，则为 ~#t~, 否则为 ~#f~.

procedure: ~(infinite? real)~

返回: 如果 ~real~ 是无限值，则为 ~#t~, 否则为 ~#f~.

procedure: ~(nan? real)~

返回: 如果 ~real~ 是 NaN，则为 ~#t~, 否则为 ~#f~.

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
  (finite? 2/3) => #t
  (infinite? 2/3) => #f
  (nan? 2/3) => #f

  (finite? 3.1415) => #t
  (infinite? 3.1415) => #f
  (nan? 3.1415) => #f

  (finite? +inf.0) => #f
  (infinite? -inf.0) => #t
  (nan? -inf.0) => #f

  (finite? +nan.0) => #f
  (infinite? +nan.0) => #f
  (nan? +nan.0) => #t
#+END_SRC

procedure: ~(quotient int1 int2)~

returns: int1 和 int2 的整数商

procedure: ~(remainder int1 int2)~

returns: int1 和 int2 的整数余数

procedure: ~(modulo int1 int2)~

returns: int1 和 int2 的整数模

libraries: (rnrs r5rs)

remainder 的结果与 int1 的符号相同，而 modulo 的结果与 int2 的符号相同。

#+BEGIN_SRC scheme
  (quotient 45 6) => 7
  (quotient 6.0 2.0) => 3.0
  (quotient 3.0 -2) => -1.0

  (remainder 16 4) => 0
  (remainder 5 2) => 1
  (remainder -45.0 7) => -3.0
  (remainder 10.0 -3.0) => 1.0
  (remainder -17 -9) => -8

  (modulo 16 4) => 0
  (modulo 5 2) => 1
  (modulo -45.0 7) => 4.0
  (modulo 10.0 -3.0) => -2.0
  (modulo -17 -9) => -8
#+END_SRC

procedure: ~(div x_1 x_2)~

procedure: ~(mod x_1 x_2)~

procedure: ~(div-and-mod x_1 x_2)~

returns: 参见下文

libraries: (rnrs base), (rnrs)

如果 x_1 和 x_2 是精确的，则 x_2 一定不能为 0. 这些过程实现了数论整数除法，其中 div 操作求商，而 mod 操作求余数或模，但每种情况均被扩展为可以处理实数。

(div x_1 x_2) 的值 n_d 是一个整数，而 (mod x_1 x_2) 的值 x_m 是一个实数，满足 x_1 = n_d · x_2 + x_m 且 0 ≤ x_m < |x_2|. 在某个实现无法以一个数字对象表示这些算式得出的数学结果时，div 和 mod 返回一个未定义数或抛出一个条件类型的 &implementation-restriction 异常。

div-and-mod 过程的行为如同如下定义。

~(define (div-and-mod x_1 x_2) (values (div x_1 x_2) (mod x_1 x_2)))~

即，除非在上述那种情况中抛出异常，它返回两个值：在两个实参上调用 div 的结果，和在两个实参上调用 mod 的结果。

#+BEGIN_SRC scheme
  (div 17 3) => 5
  (mod 17 3) => 2
  (div -17 3) => -6
  (mod -17 3) => 1
  (div 17 -3) => -5
  (mod 17 -3) => 2
  (div -17 -3) => 6
  (mod -17 -3) => 1

  (div-and-mod 17.5 3) => 5.0
  2.5
#+END_SRC

procedure: ~(div0 x_1 x_2)~

procedure: ~(mod0 x_1 x_2)~

procedure: ~(div0-and-mod0 x_1 x_2)~

returns: 参见下文

libraries: (rnrs base), (rnrs)

如果 x_1 和 x_2 是精确的，则 x_2 一定不能是 0. 这些过程和 div, mod, 以及 div-and-mod 类似，但对 "mod" 的值有不同的限制，这同时也影响到 "div" 的值。 (div0 x_1 x_2) 的值 n_d 是整数，而 (mod0 x_1 x_2) 的值 x_m 是实数， 满足 x_1 = n_d · x_2 + x_m 且 -|x_2/2| ≤ x_m < |x_2/2|. 在某个实现无法以一个数字对象表示这些算式得出的数学结果时，div0 和 mod0 返回一个未定义数或抛出一个条件类型的 &implementation-restriction 异常。

div0-and-mod0 过程的行为如同如下定义。

~(define (div0-and-mod0 x_1 x_2) (values (div0 x_1 x_2) (mod0 x_1 x_2)))~

即，除非在上述那种情况中抛出异常，它返回两个值：在两个实参上调用 div0 的结果，和在两个实参上调用 mod0 的结果。

#+BEGIN_SRC scheme
  (div0 17 3) => 6
  (mod0 17 3) => -1
  (div0 -17 3) => -6
  (mod0 -17 3) => 1
  (div0 17 -3) => -6
  (mod0 17 -3) => -1
  (div0 -17 -3) => 6
  (mod0 -17 -3) => 1

  (div0-and-mod0 17.5 3) => 6.0
  -0.5
#+END_SRC

procedure: ~(truncate real)~

returns: 在趋于 0 的方向上最接近 real 的整数

libraries: (rnrs base), (rnrs)

如果 real 是无穷数或 NaN，truncate 返回 real.

#+BEGIN_SRC scheme
  (truncate 19) => 19
  (truncate 2/3) => 0
  (truncate -2/3) => 0
  (truncate 17.3) => 17.0
  (truncate -17/2) => -8
#+END_SRC

procedure: ~(floor real)~

returns: 趋于 -\infin 的方向上最接近 real 的整数

libraries: (rnrs base), (rnrs)

如果 real 是无穷数或 NaN，floor 返回 real.

#+BEGIN_SRC scheme
  (floor 19) => 19
  (floor 2/3) => 0
  (floor -2/3) => -1
  (floor 17.3) => 17.0
  (floor -17/2) => -9
#+END_SRC

procedure: ~(ceiling real)~

returns: 趋于 +\infty 的方向上最接近 real 的整数

libraries: (rnrs base), (rnrs)

如果 real 是无穷数或 NaN，ceiling 返回 real.

#+BEGIN_SRC scheme
  (ceiling 19) => 19
  (ceiling 2/3) => 1
  (ceiling -2/3) => 0
  (ceiling 17.3) => 18.0
  (ceiling -17/2) => -8
#+END_SRC

procedure: ~(round real)~

returns: 最接近 real 的整数

libraries: (rnrs base), (rnrs)

如果 real 处于两个整数的正中间，则返回最接近的偶数。如果 real 是无穷数或 NaN，round 返回 real.

#+BEGIN_SRC scheme
  (round 19) => 19
  (round 2/3) => 1
  (round -2/3) => -1
  (round 17.3) => 17.0
  (round -17/2) => -8
  (round 2.5) => 2.0
  (round 3.5) => 4.0
#+END_SRC

procedure: ~(abs real)~

returns: real 的绝对值

libraries: (rnrs base), (rnrs)

abs 等价于 (lambda (x) (if (< x 0) (- x) x)). 对于实数输入，abs 和 magnitude (参见 183 页) 是一样的。

#+BEGIN_SRC scheme
  (abs 1) => 1
  (abs -3/4) => 3/4
  (abs 1.83) => 1.83
  (abs -0.093) => 0.093
#+END_SRC

procedure: ~(max real1 real2 ...)~

returns: real1 real2 ... 的最大值

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(max 4 -7 2 0 -6) => 4
(max 1/2 3/4 4/5 5/6 6/7) => 6/7
(max 1.5 1.3 -0.3 0.4 2.0 1.8) => 2.0
(max 5 2.0) => 5.0
(max -5 -2.0) => -2.0
(let ([ls '(7 3 5 2 9 8)])
  (apply max ls)) => 9
#+END_SRC

procedure: ~(min real1 real2 ...)~

returns: real1 real2 ... 的最小值

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(min 4 -7 2 0 -6) => -7
(min 1/2 3/4 4/5 5/6 6/7) => 1/2
(min 1.5 1.3 -0.3 0.4 2.0 1.8) => -0.3
(min 5 2.0) => 2.0
(min -5 -2.0) => -5.0
(let ([ls '(7 3 5 2 9 8)])
  (apply min ls)) => 2
#+END_SRC

procedure: ~(gcd int ...)~

returns: 实参 int ... 的最大公约数

libraries: (rnrs base), (rnrs)

结果总是非负数，即，因子 -1 会被忽略。不带实参调用时，gcd 返回 0.

#+BEGIN_SRC scheme
(gcd) => 0
(gcd 34) => 34
(gcd 33.0 15.0) => 3.0
(gcd 70 -42 28) => 14
#+END_SRC

procedure: ~(lcm int ...)~

returns: 实参 int ... 的最小公倍数

libraries: (rnrs base), (rnrs)

结果总是非负数，即，-1 的公倍数会被忽略。虽然不带实参调用 lcm 时，可能应该返回 inf.0, 但它定义为返回 1. 如果一个或更多实参为 0，lcm 返回 0.

#+BEGIN_SRC scheme
(lcm) => 1
(lcm 34) => 34
(lcm 33.0 15.0) => 165.0
(lcm 70 -42 28) => 420
(lcm 17.0 0) => 0.0
#+END_SRC

procedure: ~(expt num1 num2)~

returns: num1 的 num2 次幂

libraries: (rnrs base), (rnrs)

如果实参均为 0，expt 返回 1.

#+BEGIN_SRC scheme
(expt 2 10) => 1024
(expt 2 -10) => 1/1024
(expt 2 -10.0) => 9.765625e-4
(expt -1/2 5) => -1/32
(expt 3.0 3) => 27.0
(expt +i 2) => -1
#+END_SRC

procedure: ~(inexact num)~

returns: num 的不精确表示形式

libraries: (rnrs base), (rnrs)

如果 num 已经是不精确的，它返回 num 本身。如果当前实现不支持 num 的不精确表示形式，则可能会抛出一个条件类型的&implementation-violation 异常。对于量级超出了当前实现的不精确数字表示形式范围的输入，inexact 也可能返回 +inf.0 或 -inf.0.

#+BEGIN_SRC scheme
(inexact 3) => 3.0
(inexact 3.0) => 3.0
(inexact -1/4) => -.25
(inexact 3+4i) => 3.0+4.0i
(inexact (expt 10 20)) => 1e20
#+END_SRC

procedure: ~(exact num)~

returns: num 的精确表示形式

libraries: (rnrs base), (rnrs)

如果 num 已经是精确的，它返回 num 本身。如果当前实现不支持 num 的精确表示形式，则可能会抛出一个条件类型的&implementation-violation 异常。

#+BEGIN_SRC scheme
(exact 3.0) => 3
(exact 3) => 3
(exact -.25) => -1/4
(exact 3.0+4.0i) => 3+4i
(exact 1e20) => 100000000000000000000
#+END_SRC

procedure: ~(exact->inexact num)~

returns: num 的不精确表示形式

procedure: ~(inexact->exact num)~

returns: num 的精确表示形式

libraries: (rnrs r5rs)

这些是 inexact 和 exact 的别名，以和第 5 修订版报告兼容。

procedure: ~(rationalize real1 real2)~

returns: 参见下文

libraries: (rnrs base), (rnrs)

rationalize 返回与 real1 相差不超过 real2 的最简单的有理数。当 |n1| ≤ |n2| 且 |m1| ≤ |m2|, 且 |n1| < |n2| 或 |m1| < |m2| 时，有理数 q1 = n1/m1 比有理数 q2 = n2/m2 简单。

#+BEGIN_SRC scheme
(rationalize 3/10 1/10) => 1/3
(rationalize .3 1/10) => 0.3333333333333333
(eqv? (rationalize .3 1/10) #i1/3) => #t
#+END_SRC

procedure: ~(numerator rat)~

returns: rat 的分子

libraries: (rnrs base), (rnrs)

如果 rat 是整数，则 numerator 为 rat.

#+BEGIN_SRC scheme
(numerator 9) => 9
(numerator 9.0) => 9.0
(numerator 0.0) => 0.0
(numerator 2/3) => 2
(numerator -9/4) => -9
(numerator -2.25) => -9.0
#+END_SRC

procedure: ~(denominator rat)~

returns: rat 的分母

libraries: (rnrs base), (rnrs)

如果 rat 是整数，包括 0，则 denominator 为 1.

#+BEGIN_SRC scheme
(denominator 9) => 1
(denominator 9.0) => 1.0
(denominator 0) => 1
(denominator 0.0) => 1.0
(denominator 2/3) => 3
(denominator -9/4) => 4
(denominator -2.25) => 4.0
#+END_SRC

procedure: ~(real-part num)~

returns: num 的实部

libraries: (rnrs base), (rnrs)

如果 num 是实数，则 real-part 返回 num.

#+BEGIN_SRC scheme
(real-part 3+4i) => 3
(real-part -2.3+0.7i) => -2.3
(real-part -i) => 0
(real-part 17.2) => 17.2
(real-part -17/100) => -17/100
#+END_SRC

procedure: ~(imag-part num)~

returns: num 的虚部

libraries: (rnrs base), (rnrs)

如果 num 是实数，imag-part 返回精确的 0.

#+BEGIN_SRC scheme
(imag-part 3+4i) => 4
(imag-part -2.3+0.7i) => 0.7
(imag-part -i) => -1
(imag-part -2.5) => 0
(imag-part -17/100) => 0
#+END_SRC

procedure: ~(make-rectangular real1 real2)~

returns: 一个复数，实部为 real1，虚部为 real2

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(make-rectangular -2 7) => -2+7i
(make-rectangular 2/3 -1/2) => 2/3-1/2i
(make-rectangular 3.2 5.3) => 3.2+5.3i
#+END_SRC

procedure: ~(make-polar real1 real2)~

returns: 一个复数，模为 real1，辐角为 real2

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(make-polar 2 0) => 2
(make-polar 2.0 0.0) => 2.0+0.0i
(make-polar 1.0 (asin -1.0)) => 0.0-1.0i
(eqv? (make-polar 7.2 -0.588) 7.2@-0.588) => #t
#+END_SRC

procedure: ~(angle num)~

returns: num 极坐标形式的辐角

libraries: (rnrs base), (rnrs)

结果的范围是 -\pi（不包含）至 +\pi（包含）。

#+BEGIN_SRC scheme
(angle 7.3@1.5708) => 1.5708
(angle 5.2) => 0.0
#+END_SRC

procedure: ~(magnitude num)~

returns: num 的模

libraries: (rnrs base), (rnrs)

对实数实参，模和绝对值（参见 178 页）是一样的。复数 x + yi 的模是 +\radic x^2+y^2.

#+BEGIN_SRC scheme
(magnitude 1) => 1
(magnitude -3/4) => 3/4
(magnitude 1.83) => 1.83
(magnitude -0.093) => 0.093
(magnitude 3+4i) => 5
(magnitude 7.25@1.5708) => 7.25
#+END_SRC

procedure: ~(sqrt num)~

returns: num 的主平方根

libraries: (rnrs base), (rnrs)

Implementations are encouraged, but not required, to return exact results for exact inputs to sqrt whenever feasible.
sqrt 的输入为精确值时，只要可能，实现最好返回精确结果，但这并非硬性要求。

#+BEGIN_SRC scheme
(sqrt 16) => 4
(sqrt 1/4) => 1/2
(sqrt 4.84) => 2.2
(sqrt -4.84) => 0.0+2.2i
(sqrt 3+4i) => 2+1i
(sqrt -3.0-4.0i) => 1.0-2.0i
#+END_SRC

procedure: ~(exact-integer-sqrt n)~

returns: 参见下文

libraries: (rnrs base), (rnrs)

这个过程返回两个非负精确整数 s 和 r，其中 n = s^2 + r, 且 n < (s + 1)2.

#+BEGIN_SRC scheme
  (exact-integer-sqrt 0) => 0
  0
  (exact-integer-sqrt 9) => 3
  => 0
  (exact-integer-sqrt 19) => 4
  => 3
#+END_SRC

procedure: ~(exp num)~

returns: e 的 num 次幂

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(exp 0.0) => 1.0
(exp 1.0) => 2.7182818284590455
(exp -.5) => 0.6065306597126334
#+END_SRC

procedure: ~(log num)~

returns: num 的自然对数

procedure: ~(log num1 num2)~

returns: num1 以 num2 为底的对数

libraries: (rnrs base), (rnrs)

#+BEGIN_SRC scheme
(log 1.0) => 0.0
(log (exp 1.0)) => 1.0
(/ (log 100) (log 10)) => 2.0
(log (make-polar (exp 2.0) 1.0)) => 2.0+1.0i
#+END_SRC

#+BEGIN_SRC scheme
(log 100.0 10.0) => 2.0
(log .125 2.0) => -3.0
#+END_SRC

procedure: ~(sin num)~

procedure: ~(cos num)~

procedure: ~(tan num)~

returns: num 的 sine, cosine, 或 tangent 值

libraries: (rnrs base), (rnrs)

实参以弧度指定。

#+BEGIN_SRC scheme
(sin 0.0) => 0.0
(cos 0.0) => 1.0
(tan 0.0) => 0.0
#+END_SRC

procedure: ~(asin num)~

procedure: ~(acos num)~

returns: num 的 arc sine 或 arc cosine 值

libraries: (rnrs base), (rnrs)

结果以弧度表示。复数 z 的 arc sine 和 arc cosine 依如下定义。

sin^-1(z) = -ilog(iz + \radic1-z^2)

cos^-1(z) = \pi/2 - sin^-1(z)

#+BEGIN_SRC scheme
  (define pi (* (asin 1) 2))
  (= (* (acos 0) 2) pi) => #t
#+END_SRC

procedure: ~(atan num)~

procedure: ~(atan real1 real2)~

returns: 参见下文

libraries: (rnrs base), (rnrs)

When passed a single complex argument num (the first form), atan returns the arc tangent of num. The arc tangent of a complex number z is defined as follows.

tan^-1(z) = (log(1+iz) - log(1-iz))/(2i)

When passed two real arguments (the second form), atan 等价于 (lambda (y x) (angle (make-rectangular x y))).

#+BEGIN_SRC scheme
(define pi (* (atan 1) 4))
(= (* (atan 1.0 0.0) 2) pi) => #t
#+END_SRC

procedure: ~(bitwise-not exint)~

returns: the bitwise not of exint

procedure: ~(bitwise-and exint ...)~

returns: the bitwise and of exint ...

procedure: ~(bitwise-ior exint ...)~

returns: the bitwise inclusive or of exint ...

procedure: ~(bitwise-xor exint ...)~

returns: the bitwise exclusive or of exint ...

libraries: (rnrs arithmetic bitwise), (rnrs)

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-not 0) => -1
(bitwise-not 3) => -4
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-and #b01101 #b00111) => #b00101
(bitwise-ior #b01101 #b00111) => #b01111
(bitwise-xor #b01101 #b00111) => #b01010
#+END_SRC

procedure: ~(bitwise-if exint1 exint2 exint3)~

returns: the bitwise "if" of its arguments

libraries: (rnrs arithmetic bitwise), (rnrs)

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

For each bit set in exint1, the corresponding bit of the result is taken from exint2, and for each bit not set in exint1, the corresponding bit of the result is taken from x3.

(bitwise-if #b101010 #b111000 #b001100) => #b101100

bitwise-if might be defined as follows:

#+BEGIN_SRC scheme
(define bitwise-if
  (lambda (exint1 exint2 exint3)
#+END_SRC
    (bitwise-ior
      (bitwise-and exint1 exint2)
      (bitwise-and (bitwise-not exint1) exint3))))

procedure: ~(bitwise-bit-count exint)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

For nonnegative inputs, bitwise-bit-count returns the number of bits set in the two's complement representation of exint. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in the two's complement representation of exint, which 等价于 (bitwise-not (bitwise-bit-count (bitwise-not exint))).

#+BEGIN_SRC scheme
(bitwise-bit-count #b00000) => 0
(bitwise-bit-count #b00001) => 1
(bitwise-bit-count #b00100) => 1
(bitwise-bit-count #b10101) => 3
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-bit-count -1) => -1
(bitwise-bit-count -2) => -2
(bitwise-bit-count -4) => -3
#+END_SRC

procedure: ~(bitwise-length exint)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

This procedure returns the number of bits of the smallest two's complement representation of exint, not including the sign bit for negative numbers. For 0 bitwise-length returns 0.

#+BEGIN_SRC scheme
(bitwise-length #b00000) => 0
(bitwise-length #b00001) => 1
(bitwise-length #b00100) => 3
(bitwise-length #b00110) => 3
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-length -1) => 0
(bitwise-length -6) => 3
(bitwise-length -9) => 4
#+END_SRC

procedure: ~(bitwise-first-bit-set exint)~

returns: the index of the least significant bit set in exint

libraries: (rnrs arithmetic bitwise), (rnrs)

The input is treated as if represented in two's complement, even if it is not represented that way internally.

If exint is 0, bitwise-first-bit-set returns -1.

#+BEGIN_SRC scheme
(bitwise-first-bit-set #b00000) => -1
(bitwise-first-bit-set #b00001) => 0
(bitwise-first-bit-set #b01100) => 2
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-first-bit-set -1) => 0
(bitwise-first-bit-set -2) => 1
(bitwise-first-bit-set -3) => 0
#+END_SRC

procedure: ~(bitwise-bit-set? exint1 exint2)~

returns: #t if bit exint2 of exint1 is set, #f otherwise

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. The two's complement representation of a nonnegative number conceptually extends to the left (toward more significant bits) with an infinite number of zero bits, and the two's complement representation of a negative number conceptually extends to the left with an infinite number of one bits. Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the empty set, -1 is the universe, and bitwise-bit-set? is used to test for membership.

#+BEGIN_SRC scheme
(bitwise-bit-set? #b01011 0) => #t
(bitwise-bit-set? #b01011 2) => #f
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-bit-set? -1 0) => #t
(bitwise-bit-set? -1 20) => #t
(bitwise-bit-set? -3 1) => #f
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-bit-set? 0 5000) => #f
(bitwise-bit-set? -1 5000) => #t
#+END_SRC

procedure: ~(bitwise-copy-bit exint1 exint2 exint3)~

returns: exint1 with bit exint2 replaced by exint3

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. exint3 must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of exint3. exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-copy-bit #b01110 0 1) => #b01111
(bitwise-copy-bit #b01110 2 0) => #b01010
#+END_SRC

procedure: ~(bitwise-bit-field exint1 exint2 exint3)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the number represented by extracting from exint1 the sequence of bits from exint2 (inclusive) to exint3 (exclusive). exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-bit-field #b10110 0 3) => #b00110
(bitwise-bit-field #b10110 1 3) => #b00011
(bitwise-bit-field #b10110 2 3) => #b00001
(bitwise-bit-field #b10110 3 3) => #b00000
#+END_SRC

procedure: ~(bitwise-copy-bit-field exint1 exint2 exint3 exint4)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns exint1 with the n bits from exint2 (inclusive) to exint3 (exclusive) replaced by the low-order n bits of exint4. exint1 and exint4 are treated as if represented in two's complement, even if they are not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-copy-bit-field #b10000 0 3 #b10101) => #b10101
(bitwise-copy-bit-field #b10000 1 3 #b10101) => #b10010
(bitwise-copy-bit-field #b10000 2 3 #b10101) => #b10100
(bitwise-copy-bit-field #b10000 3 3 #b10101) => #b10000
#+END_SRC

procedure: ~(bitwise-arithmetic-shift-right exint1 exint2)~

returns: exint1 arithmetically shifted right by exint2 bits

procedure: ~(bitwise-arithmetic-shift-left exint1 exint2)~

returns: exint1 shifted left by exint2 bits

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 must be nonnegative. exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-arithmetic-shift-right #b10000 3) => #b00010
(bitwise-arithmetic-shift-right -1 1) => -1
(bitwise-arithmetic-shift-right -64 3) => -8
#+END_SRC

#+BEGIN_SRC scheme
(bitwise-arithmetic-shift-left #b00010 2) => #b01000
(bitwise-arithmetic-shift-left -1 2) => -4
#+END_SRC

procedure: ~(bitwise-arithmetic-shift exint1 exint2)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

If exint2 is negative, bitwise-arithmetic-shift returns the result of arithmetically shifting exint1 right by -exint2 bits. Otherwise, bitwise-arithmetic-shift returns the result of shifting exint1 left by exint2 bits. exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-arithmetic-shift #b10000 -3) => #b00010
(bitwise-arithmetic-shift -1 -1) => -1
(bitwise-arithmetic-shift -64 -3) => -8
(bitwise-arithmetic-shift #b00010 2) => #b01000
(bitwise-arithmetic-shift -1 2) => -4
#+END_SRC

Thus, bitwise-arithmetic-shift behaves as if defined as follows.

#+BEGIN_SRC scheme
(define bitwise-arithmetic-shift
  (lambda (exint1 exint2)
    (if (< exint2 0)
        (bitwise-arithmetic-shift-right exint1 (- exint2))
        (bitwise-arithmetic-shift-left exint1 exint2))))
#+END_SRC

procedure: ~(bitwise-rotate-bit-field exint1 exint2 exint3 exint4)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2, exint3, and exint4 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the result of shifting the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive) left by (mod exint4 (- exint3 exint2)) bits, with the bits shifted out of the range inserted at the bottom end of the range. exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-rotate-bit-field #b00011010 0 5 3) => #b00010110
(bitwise-rotate-bit-field #b01101011 2 7 3) => #b01011011
#+END_SRC

procedure: ~(bitwise-reverse-bit-field exint1 exint2 exint3)~

returns: 参见下文

libraries: (rnrs arithmetic bitwise), (rnrs)

exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the result of reversing the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive). exint1 is treated as if represented in two's complement, even if it is not represented that way internally.

#+BEGIN_SRC scheme
(bitwise-reverse-bit-field #b00011010 0 5) => #b00001011
(bitwise-reverse-bit-field #b01101011 2 7) => #b00101111
#+END_SRC

procedure: ~(string->number string)~

procedure: ~(string->number string radix)~

returns: the number represented by string, or #f

libraries: (rnrs base), (rnrs)

If string is a valid representation of a number, that number is returned, otherwise #f is returned. The number is interpreted in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix defaults to 10. Any radix specifier within string, e.g., #x, overrides the radix argument.

#+BEGIN_SRC scheme
(string->number "0") => 0
(string->number "3.4e3") => 3400.0
(string->number "#x#e-2e2") => -738
(string->number "#e-2e2" 16) => -738
(string->number "#i15/16") => 0.9375
(string->number "10" 16) => 16
#+END_SRC

procedure: ~(number->string num)~

procedure: ~(number->string num radix)~

procedure: ~(number->string num radix precision)~

returns: an external representation of num as a string

libraries: (rnrs base), (rnrs)

The num is expressed in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix defaults to 10. In any case, no radix specifier appears in the resulting string.

The external representation is such that, when converted back into a number using string->number, the resulting numeric value 等价于 num. That is, for all inputs:

#+BEGIN_SRC scheme
(eqv? (string->number
        (number->string num radix)
#+END_SRC
        radix)
      num)

returns #t. An exception with condition type &implementation-restriction is raised if this is not possible.

If precision is provided, it must be an exact positive integer, num must be inexact, and radix must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width m, where m is the least possible value greater than or equal to precision that makes the expression above true.

If radix is 10, inexact values of num are expressed using the fewest number of significant digits possible [5] without violating the above restriction.

#+BEGIN_SRC scheme
(number->string 3.4) => "3.4"
(number->string 1e2) => "100.0"
(number->string 1e-23) => "1e-23"
(number->string -7/2) => "-7/2"
(number->string 220/9 16) => "DC/9"
#+END_SRC

** Section 6.5. Fixnums

Fixnums represent exact integers in the fixnum range, which is required to be a closed range [-2w-1,2w-1 - 1], where w (the fixnum width) is at least 24. The implementation-specific value of w may be determined via the procedure fixnum-width, and the endpoints of the range may be determined via the procedures least-fixnum and greatest-fixnum.

The names of arithmetic procedures that operate only on fixnums begin with the prefix "fx" to set them apart from their generic counterparts.

Procedure arguments required to be fixnums are named fx, possibly with a suffix, e.g., fx_2.

Unless otherwise specified, the numeric values of fixnum-specific procedures are fixnums. If the value of a fixnum operation should be a fixnum, but the mathematical result would be outside the fixnum range, an exception with condition type &implementation-restriction is raised.

Bit and shift operations on fixnums assume that fixnums are represented in two's complement, even if they are not represented that way internally.

procedure: ~(fixnum? obj)~

returns: #t if obj is a fixnum, #f otherwise

libraries: (rnrs arithmetic fixnums), (rnrs)


(fixnum? 0) => #t
(fixnum? -1) => #t
(fixnum? (- (expt 2 23))) => #t
(fixnum? (- (expt 2 23) 1)) => #t

procedure: ~(least-fixnum)~

returns: the least (most negative) fixnum supported by the implementation

procedure: ~(greatest-fixnum)~

returns: the greatest (most positive) fixnum supported by the implementation

libraries: (rnrs arithmetic fixnums), (rnrs)


(fixnum? (- (least-fixnum) 1)) => #f
(fixnum? (least-fixnum)) => #t
(fixnum? (greatest-fixnum)) => #t
(fixnum? (+ (greatest-fixnum) 1)) => #f

procedure: ~(fixnum-width)~

returns: the implementation-dependent fixnum width

libraries: (rnrs arithmetic fixnums), (rnrs)


As described in the lead-in to this section, the fixnum width determines the size of the fixnum range and must be at least 24.

(define w (fixnum-width))
(= (least-fixnum) (- (expt 2 (- w 1)))) => #t
(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) => #t
(>= w 24) => #t

procedure: ~(fx=? fx_1 fx_2 fx3 ...)~

procedure: ~(fx<? fx_1 fx_2 fx3 ...)~

procedure: ~(fx>? fx_1 fx_2 fx3 ...)~

procedure: ~(fx<=? fx_1 fx_2 fx3 ...)~

procedure: ~(fx>=? fx_1 fx_2 fx3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs arithmetic fixnums), (rnrs)


The predicate fx=? returns #t if its arguments are equal. The predicate fx<? returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fx>? returns #t if its arguments are monotonically decreasing. The predicate fx<=? returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fx>=? returns #t if its arguments are monotonically nonincreasing.

(fx=? 0 0) => #t
(fx=? -1 1) => #f
(fx<? (least-fixnum) 0 (greatest-fixnum)) => #t
(let ([x 3]) (fx<=? 0 x 9)) => #t
(fx>? 5 4 3 2 1) => #t
(fx<=? 1 3 2) => #f
(fx>=? 0 0 (least-fixnum)) => #t

procedure: ~(fxzero? fx)~

returns: #t if fx is zero, #f otherwise

procedure: ~(fxpositive? fx)~

returns: #t if fx is greater than zero, #f otherwise

procedure: ~(fxnegative? fx)~

returns: #t if fx is less than zero, #f otherwise

libraries: (rnrs arithmetic fixnums), (rnrs)


fxzero? 等价于 (lambda (x) (fx=? x 0)), fxpositive? 等价于 (lambda (x) (fx>? x 0)), and fxnegative? to (lambda (x) (fx<? x 0)).

(fxzero? 0) => #t
(fxzero? 1) => #f

(fxpositive? 128) => #t
(fxpositive? 0) => #f
(fxpositive? -1) => #f

(fxnegative? -65) => #t
(fxnegative? 0) => #f
(fxnegative? 1) => #f

procedure: ~(fxeven? fx)~

returns: #t if fx is even, #f otherwise

procedure: ~(fxodd? fx)~

returns: #t if fx is odd, #f otherwise

libraries: (rnrs arithmetic fixnums), (rnrs)


(fxeven? 0) => #t
(fxeven? 1) => #f
(fxeven? -1) => #f
(fxeven? -10) => #t

(fxodd? 0) => #f
(fxodd? 1) => #t
(fxodd? -1) => #t
(fxodd? -10) => #f

procedure: ~(fxmin fx_1 fx_2 ...)~

returns: the minimum of fx_1 fx_2 ...

procedure: ~(fxmax fx_1 fx_2 ...)~

returns: the maximum of fx_1 fx_2 ...

libraries: (rnrs arithmetic fixnums), (rnrs)


(fxmin 4 -7 2 0 -6) => -7

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmin ls)) => 2

(fxmax 4 -7 2 0 -6) => 4

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmax ls)) => 9

procedure: ~(fx+ fx_1 fx_2)~

returns: the sum of fx_1 and fx_2

libraries: (rnrs arithmetic fixnums), (rnrs)


(fx+ -3 4) => 1

procedure: ~(fx- fx)~

returns: the additive inverse of fx

procedure: ~(fx- fx_1 fx_2)~

returns: the difference between fx_1 and fx_2

libraries: (rnrs arithmetic fixnums), (rnrs)


(fx- 3) => -3
(fx- -3 4) => -7

procedure: ~(fx* fx_1 fx_2)~

returns: the product of fx_1 and fx_2

libraries: (rnrs arithmetic fixnums), (rnrs)


(fx* -3 4) => -12

procedure: ~(fxdiv fx_1 fx_2)~

procedure: ~(fxmod fx_1 fx_2)~

procedure: ~(fxdiv-and-mod fx_1 fx_2)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 must not be zero. These are fixnum-specific versions of the generic div, mod, and div-and-mod.

(fxdiv 17 3) => 5
(fxmod 17 3) => 2
(fxdiv -17 3) => -6
(fxmod -17 3) => 1
(fxdiv 17 -3) => -5
(fxmod 17 -3) => 2
(fxdiv -17 -3) => 6
(fxmod -17 -3) => 1

(fxdiv-and-mod 17 3) => 5
                      2

procedure: ~(fxdiv0 fx_1 fx_2)~

procedure: ~(fxmod0 fx_1 fx_2)~

procedure: ~(fxdiv0-and-mod0 fx_1 fx_2)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 must not be zero. These are fixnum-specific versions of the generic div0, mod0, and div0-and-mod0.

(fxdiv0 17 3) => 6
(fxmod0 17 3) => -1
(fxdiv0 -17 3) => -6
(fxmod0 -17 3) => 1
(fxdiv0 17 -3) => -6
(fxmod0 17 -3) => -1
(fxdiv0 -17 -3) => 6
(fxmod0 -17 -3) => 1

(fxdiv0-and-mod0 17 3) => 6
                        -1

procedure: ~(fx+/carry fx_1 fx_2 fx3)~

procedure: ~(fx-/carry fx_1 fx_2 fx3)~

procedure: ~(fx*/carry fx_1 fx_2 fx3)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic.

These procedures return the two fixnum values of the following computations. For fx+/carry:

(let* ([s (+ fx_1 fx_2 fx3)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))

for fx-/carry:

(let* ([d (- fx_1 fx_2 fx3)]
       [d0 (mod0 d (expt 2 (fixnum-width)))]
       [d1 (div0 d (expt 2 (fixnum-width)))])
  (values d0 d1))

and for fx*/carry:

(let* ([s (+ (* fx_1 fx_2) fx3)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))

procedure: ~(fxnot fx)~

returns: the bitwise not of fx

procedure: ~(fx and fx ...)~

returns: the bitwise and of fx ...

procedure: ~(fxior fx ...)~

returns: the bitwise inclusive or of fx ...

procedure: ~(fxxor fx ...)~

returns: the bitwise exclusive or of fx ...

libraries: (rnrs arithmetic fixnums), (rnrs)


(fxnot 0) => -1
(fxnot 3) => -4

(fx and #b01101 #b00111) => #b00101
(fxior #b01101 #b00111) => #b01111
(fxxor #b01101 #b00111) => #b01010

procedure: ~(fxif fx_1 fx_2 fx3)~

returns: the bitwise "if" of its arguments

libraries: (rnrs arithmetic fixnums), (rnrs)


For each bit set in fx_1, the corresponding bit of the result is taken from fx_2, and for each bit not set in fx_1, the corresponding bit of the result is taken from x3.

(fxif #b101010 #b111000 #b001100) => #b101100

fxif might be defined as follows:

(define fxif
  (lambda (fx_1 fx_2 fx3)
    (fxior (fx and fx_1 fx_2)
           (fx and (fxnot fx_1) fx3))))

procedure: ~(fxbit-count fx)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


For nonnegative inputs, fxbit-count returns the number of bits set in the two's complement representation of fx. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in fx, which 等价于 (fxnot (fxbit-count (fxnot fx))).

(fxbit-count #b00000) => 0
(fxbit-count #b00001) => 1
(fxbit-count #b00100) => 1
(fxbit-count #b10101) => 3

(fxbit-count -1) => -1
(fxbit-count -2) => -2
(fxbit-count -4) => -3

procedure: ~(fxlength fx)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


This procedure returns the number of bits of the smallest two's complement representation of fx, not including the sign bit for negative numbers. For 0 fxlength returns 0.

(fxlength #b00000) => 0
(fxlength #b00001) => 1
(fxlength #b00100) => 3
(fxlength #b00110) => 3

(fxlength -1) => 0
(fxlength -6) => 3
(fxlength -9) => 4

procedure: ~(fxfirst-bit-set fx)~

returns: the index of the least significant bit set in fx

libraries: (rnrs arithmetic fixnums), (rnrs)


If fx is 0, fxfirst-bit-set returns -1.

(fxfirst-bit-set #b00000) => -1
(fxfirst-bit-set #b00001) => 0
(fxfirst-bit-set #b01100) => 2

(fxfirst-bit-set -1) => 0
(fxfirst-bit-set -2) => 1
(fxfirst-bit-set -3) => 0

procedure: ~(fxbit-set? fx_1 fx_2)~

returns: #t if bit fx_2 of fx_1 is set, #f otherwise

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 must be nonnegative. It is taken as a zero-based index for the bits in the two's complement representation of fx_1, with the sign bit virtually replicated an infinite number of positions to the left.

(fxbit-set? #b01011 0) => #t
(fxbit-set? #b01011 2) => #f

(fxbit-set? -1 0) => #t
(fxbit-set? -1 20) => #t
(fxbit-set? -3 1) => #f
(fxbit-set? 0 (- (fixnum-width) 1)) => #f
(fxbit-set? -1 (- (fixnum-width) 1)) => #t

procedure: ~(fxcopy-bit fx_1 fx_2 fx3)~

returns: fx_1 with bit fx_2 replaced by fx3

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 must be nonnegative and less than the value of (- (fixnum-width) 1). fx3 must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of fx3.

(fxcopy-bit #b01110 0 1) => #b01111
(fxcopy-bit #b01110 2 0) => #b01010

procedure: ~(fxbit-field fx_1 fx_2 fx3)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx_2 must not be greater than fx3. This procedure returns the number represented by extracting from fx_1 the sequence of bits from fx_2 (inclusive) to fx3 (exclusive).

(fxbit-field #b10110 0 3) => #b00110
(fxbit-field #b10110 1 3) => #b00011
(fxbit-field #b10110 2 3) => #b00001
(fxbit-field #b10110 3 3) => #b00000

procedure: ~(fxcopy-bit-field fx_1 fx_2 fx3 fx4)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx_2 must not be greater than fx3. This procedure returns fx_1 with n bits from fx_2 (inclusive) to fx3 (exclusive) replaced by the low-order n bits of x4.

(fxcopy-bit-field #b10000 0 3 #b10101) => #b10101
(fxcopy-bit-field #b10000 1 3 #b10101) => #b10010
(fxcopy-bit-field #b10000 2 3 #b10101) => #b10100
(fxcopy-bit-field #b10000 3 3 #b10101) => #b10000

procedure: ~(fxarithmetic-shift-right fx_1 fx_2)~

returns: fx_1 arithmetically shifted right by fx_2 bits

procedure: ~(fxarithmetic-shift-left fx_1 fx_2)~

returns: fx_1 shifted left by fx_2 bits

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 must be nonnegative and less than the value of (fixnum-width).

(fxarithmetic-shift-right #b10000 3) => #b00010
(fxarithmetic-shift-right -1 1) => -1
(fxarithmetic-shift-right -64 3) => -8

(fxarithmetic-shift-left #b00010 2) => #b01000
(fxarithmetic-shift-left -1 2) => -4

procedure: ~(fxarithmetic-shift fx_1 fx_2)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


The absolute value of fx_2 must be less than the value of (fixnum-width). If fx_2 is negative, fxarithmetic-shift returns the result of arithmetically shifting fx_1 right by fx_2 bits. Otherwise, fxarithmetic-shift returns the result of shifting fx_1 left by fx_2 bits.

(fxarithmetic-shift #b10000 -3) => #b00010
(fxarithmetic-shift -1 -1) => -1
(fxarithmetic-shift -64 -3) => -8
(fxarithmetic-shift #b00010 2) => #b01000
(fxarithmetic-shift -1 2) => -4

Thus, fxarithmetic-shift behaves as if defined as follows.

(define fxarithmetic-shift
  (lambda (fx_1 fx_2)
    (if (fx<? fx_2 0)
        (fxarithmetic-shift-right fx_1 (fx- fx_2))
        (fxarithmetic-shift-left fx_1 fx_2))))

procedure: ~(fxrotate-bit-field fx_1 fx_2 fx3 fx4)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2, fx3, and fx4 must be nonnegative and less than the value of (fixnum-width), fx_2 must not be greater than fx3, and fx4 must not be greater than the difference between fx3 and fx_2.

This procedure returns the result of shifting the bits of fx_1 from bit fx_2 (inclusive) through bit fx3 (exclusive) left by fx4 bits, with the bits shifted out of the range inserted at the bottom end of the range.

(fxrotate-bit-field #b00011010 0 5 3) => #b00010110
(fxrotate-bit-field #b01101011 2 7 3) => #b01011011

procedure: ~(fxreverse-bit-field fx_1 fx_2 fx3)~

returns: 参见下文

libraries: (rnrs arithmetic fixnums), (rnrs)


fx_2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx_2 must not be greater than fx3. This procedure returns the result of reversing the bits of fx_1 from bit fx_2 (inclusive) through bit fx3 (exclusive).

(fxreverse-bit-field #b00011010 0 5) => #b00001011
(fxreverse-bit-field #b01101011 2 7) => #b00101111

** Section 6.6. Flonums

Flonums represent inexact real numbers. Implementations are required to represent as a flonum any inexact real number whose lexical syntax contains no vertical bar and no exponent marker other than e, but are not required to represent any other inexact real number as a flonum.

Implementations typically use the IEEE double-precision floating-point representation for flonums, but implementations are not required to do so or even to use a floating-point representation of any sort, despite the name "flonum."

This section describes operations on flonums. Flonum-specific procedure names begin with the prefix "fl" to set them apart from their generic counterparts.

Procedure arguments required to be flonums are named fl, possibly with suffix, e.g., fl2. Unless otherwise specified, the numeric values of flonum-specific procedures are flonums.

procedure: ~(flonum? obj)~

returns: #t if obj is a flonum, otherwise #f

libraries: (rnrs arithmetic flonums), (rnrs)


(flonum? 0) => #f
(flonum? 3/4) => #f
(flonum? 3.5) => #t
(flonum? .02) => #t
(flonum? 1e10) => #t
(flonum? 3.0+0.0i) => #f

procedure: ~(fl=? fl1 fl2 fl3 ...)~

procedure: ~(fl<? fl1 fl2 fl3 ...)~

procedure: ~(fl>? fl1 fl2 fl3 ...)~

procedure: ~(fl<=? fl1 fl2 fl3 ...)~

procedure: ~(fl>=? fl1 fl2 fl3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs arithmetic flonums), (rnrs)


The predicate fl=? returns #t if its arguments are equal. The predicate fl<? returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fl>? returns #t if its arguments are monotonically decreasing. The predicate fl<=? returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fl>=? returns #t if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns #t.

Comparisons involving NaNs always return #f.

(fl=? 0.0 0.0) => #t
(fl<? -1.0 0.0 1.0) => #t
(fl>? -1.0 0.0 1.0) => #f
(fl<=? 0.0 3.0 3.0) => #t
(fl>=? 4.0 3.0 3.0) => #t
(fl<? 7.0 +inf.0) => #t
(fl=? +nan.0 0.0) => #f
(fl=? +nan.0 +nan.0) => #f
(fl<? +nan.0 +nan.0) => #f
(fl<=? +nan.0 +inf.0) => #f
(fl>=? +nan.0 +inf.0) => #f

procedure: ~(flzero? fl)~

returns: #t if fl is zero, #f otherwise

procedure: ~(flpositive? fl)~

returns: #t if fl is greater than zero, #f otherwise

procedure: ~(flnegative? fl)~

returns: #t if fl is less than zero, #f otherwise

libraries: (rnrs arithmetic flonums), (rnrs)


flzero? 等价于 (lambda (x) (fl=? x 0.0)), flpositive? 等价于 (lambda (x) (fl>? x 0.0)), and flnegative? to (lambda (x) (fl<? x 0.0)).

Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.

(flzero? 0.0) => #t
(flzero? 1.0) => #f

(flpositive? 128.0) => #t
(flpositive? 0.0) => #f
(flpositive? -1.0) => #f

(flnegative? -65.0) => #t
(flnegative? 0.0) => #f
(flnegative? 1.0) => #f

(flzero? -0.0) => #t
(flnegative? -0.0) => #f

(flnegative? +nan.0) => #f
(flzero? +nan.0) => #f
(flpositive? +nan.0) => #f

(flnegative? +inf.0) => #f
(flnegative? -inf.0) => #t

procedure: ~(flinteger? fl)~

returns: #t if fl is integer, #f otherwise

libraries: (rnrs arithmetic flonums), (rnrs)


(flinteger? 0.0) => #t
(flinteger? -17.0) => #t
(flinteger? +nan.0) => #f
(flinteger? +inf.0) => #f

procedure: ~(flfinite? fl)~

returns: #t if fl is finite, #f otherwise

procedure: ~(flinfinite? fl)~

returns: #t if fl is infinite, #f otherwise

procedure: ~(flnan? fl)~

returns: #t if fl is a NaN, #f otherwise

libraries: (rnrs arithmetic flonums), (rnrs)


(flfinite? 3.1415) => #t
(flinfinite? 3.1415) => #f
(flnan? 3.1415) => #f

(flfinite? +inf.0) => #f
(flinfinite? -inf.0) => #t
(flnan? -inf.0) => #f

(flfinite? +nan.0) => #f
(flinfinite? +nan.0) => #f
(flnan? +nan.0) => #t

procedure: ~(fleven? fl-int)~

returns: #t if fl-int is even, #f otherwise

procedure: ~(flodd? fl-int)~

returns: #t if fl-int is odd, #f otherwise

libraries: (rnrs arithmetic flonums), (rnrs)


fl-int must be an integer-valued flonum.

(fleven? 0.0) => #t
(fleven? 1.0) => #f
(fleven? -1.0) => #f
(fleven? -10.0) => #t

(flodd? 0.0) => #f
(flodd? 1.0) => #t
(flodd? -1.0) => #t
(flodd? -10.0) => #f

procedure: ~(flmin fl1 fl2 ...)~

returns: the minimum of fl1 fl2 ...

procedure: ~(flmax fl1 fl2 ...)~

returns: the maximum of fl1 fl2 ...

libraries: (rnrs arithmetic flonums), (rnrs)


(flmin 4.2 -7.5 2.0 0.0 -6.4) => -7.5

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmin ls)) => 2.6

(flmax 4.2 -7.5 2.0 0.0 -6.4) => 4.2

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmax ls)) => 8.0

procedure: ~(fl+ fl ...)~

returns: the sum of the arguments fl ...

libraries: (rnrs arithmetic flonums), (rnrs)


When called with no arguments, fl+ returns 0.0.

(fl+) => 0.0
(fl+ 1.0 2.5) => 3.25
(fl+ 3.0 4.25 5.0) => 12.25
(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) => 15.0

procedure: ~(fl- fl)~

returns: the additive inverse of fl

procedure: ~(fl- fl1 fl2 fl3 ...)~

returns: the difference between fl1 and the sum of fl2 fl3 ...

libraries: (rnrs arithmetic flonums), (rnrs)


With an IEEE floating-point representation of flonums, the single-argument fl- 等价于

(lambda (x) (fl* -1.0 x))

or

(lambda (x) (fl- -0.0 x))

but not

(lambda (x) (fl- 0.0 x))

since the latter returns 0.0 rather than -0.0 for 0.0.

(fl- 0.0) => -0.0
(fl- 3.0) => -3.0
(fl- 4.0 3.0) => 1.0
(fl- 4.0 3.0 2.0 1.0) => -2.0

procedure: ~(fl* fl ...)~

returns: the product of the arguments fl ...

libraries: (rnrs arithmetic flonums), (rnrs)


When called with no arguments, fl* returns 1.0.

(fl*) => 1.0
(fl* 1.5 2.5) => 3.75
(fl* 3.0 -4.0 5.0) => -60.0
(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) => 120.0

procedure: ~(fl/ fl)~

returns: the multiplicative inverse of fl

procedure: ~(fl/ fl1 fl2 fl3 ...)~

returns: the result of dividing fl1 by the product of fl2 fl3 ...

libraries: (rnrs arithmetic flonums), (rnrs)


(fl/ -4.0) => -0.25
(fl/ 8.0 -2.0) => -4.0
(fl/ -9.0 2.0) => -4.5
(fl/ 60.0 5.0 3.0 2.0) => 2.0

procedure: ~(fldiv fl1 fl2)~

procedure: ~(flmod fl1 fl2)~

procedure: ~(fldiv-and-mod fl1 fl2)~

returns: 参见下文

libraries: (rnrs arithmetic flonums), (rnrs)


These are flonum-specific versions of the generic div, mod, and div-and-mod.

(fldiv 17.0 3.0) => 5.0
(flmod 17.0 3.0) => 2.0
(fldiv -17.0 3.0) => -6.0
(flmod -17.0 3.0) => 1.0
(fldiv 17.0 -3.0) => -5.0
(flmod 17.0 -3.0) => 2.0
(fldiv -17.0 -3.0) => 6.0
(flmod -17.0 -3.0) => 1.0

(fldiv-and-mod 17.5 3.75) => 4.0
                           2.5

procedure: ~(fldiv0 fl1 fl2)~

procedure: ~(flmod0 fl1 fl2)~

procedure: ~(fldiv0-and-mod0 fl1 fl2)~

returns: 参见下文

libraries: (rnrs arithmetic flonums), (rnrs)


These are flonum-specific versions of the generic div0, mod0, and div0-and-mod0.

(fldiv0 17.0 3.0) => 6.0
(flmod0 17.0 3.0) => -1.0
(fldiv0 -17.0 3.0) => -6.0
(flmod0 -17.0 3.0) => 1.0
(fldiv0 17.0 -3.0) => -6.0
(flmod0 17.0 -3.0) => -1.0
(fldiv0 -17.0 -3.0) => 6.0
(flmod0 -17.0 -3.0) => 1.0

(fldiv0-and-mod0 17.5 3.75) => 5.0
                             -1.25

procedure: ~(flround fl)~

returns: the integer closest to fl

procedure: ~(fltruncate fl)~

returns: the integer closest to fl toward zero

procedure: ~(flfloor fl)~

returns: the integer closest to fl toward =>

procedure: ~(flceiling fl)~

returns: the integer closest to fl toward =>

libraries: (rnrs arithmetic flonums), (rnrs)


If fl is an integer, NaN, or infinity, each of these procedures returns fl. If fl is exactly between two integers, flround returns the closest even integer.

(flround 17.3) => 17.0
(flround -17.3) => -17.0
(flround 2.5) => 2.0
(flround 3.5) => 4.0

(fltruncate 17.3) => 17.0
(fltruncate -17.3) => -17.0

(flfloor 17.3) => 17.0
(flfloor -17.3) => -18.0

(flceiling 17.3) => 18.0
(flceiling -17.3) => -17.0

procedure: ~(flnumerator fl)~

returns: the numerator of fl

procedure: ~(fldenominator fl)~

returns: the denominator of fl

libraries: (rnrs arithmetic flonums), (rnrs)


If fl is an integer, including 0.0, or infinity, the numerator is fl and the denominator is 1.0.

(flnumerator -9.0) => -9.0
(fldenominator -9.0) => 1.0
(flnumerator 0.0) => 0.0
(fldenominator 0.0) => 1.0
(flnumerator -inf.0) => -inf.0
(fldenominator -inf.0) => 1.0

The following hold for IEEE floats, but not necessarily other flonum representations.

(flnumerator 3.5) => 7.0
(fldenominator 3.5) => 2.0

procedure: ~(flabs fl)~

returns: absolute value of fl

libraries: (rnrs arithmetic flonums), (rnrs)


(flabs 3.2) => 3.2
(flabs -2e-20) => 2e-20

procedure: ~(flexp fl)~

returns: e to the fl power

procedure: ~(fllog fl)~

returns: the natural logarithm of fl

procedure: ~(fllog fl1 fl2)~

returns: the base-fl2 logarithm of fl1

libraries: (rnrs arithmetic flonums), (rnrs)


(flexp 0.0) => 1.0
(flexp 1.0) => 2.7182818284590455

(fllog 1.0) => 0.0
(fllog (exp 1.0)) => 1.0
(fl/ (fllog 100.0) (fllog 10.0)) => 2.0

(fllog 100.0 10.0) => 2.0
(fllog .125 2.0) => -3.0

procedure: ~(flsin fl)~

returns: the sine of fl

procedure: ~(flcos fl)~

returns: the cosine of fl

procedure: ~(fltan fl)~

returns: the tangent of fl

libraries: (rnrs arithmetic flonums), (rnrs)


procedure: ~(flasin fl)~

returns: the arc sine of fl

procedure: ~(flacos fl)~

returns: the arc cosine of fl

procedure: ~(flatan fl)~

returns: the arc tangent of fl

procedure: ~(flatan fl1 fl2)~

returns: the arc tangent of fl1/fl2

libraries: (rnrs arithmetic flonums), (rnrs)


procedure: ~(flsqrt fl)~

returns: the principal square root of fl

libraries: (rnrs arithmetic flonums), (rnrs)


Returns the principal square root of fl. The square root of -0.0 should be -0.0. The result for other negative numbers may be a NaN or some other unspecified flonum.

(flsqrt 4.0) => 2.0
(flsqrt 0.0) => 0.0
(flsqrt -0.0) => -0.0

procedure: ~(flexpt fl1 fl2)~

returns: fl1 raised to the fl2 power

libraries: (rnrs arithmetic flonums), (rnrs)


If fl1 is negative and fl2 is not an integer, the result may be a NaN or some other unspecified flonum. If fl1 and fl2 are both zero, the result is 1.0. If fl1 is zero and fl2 is positive, the result is zero. In other cases where fl1 is zero, the result may be a NaN or some other unspecified flonum.

(flexpt 3.0 2.0) => 9.0
(flexpt 0.0 +inf.0) => 0.0

procedure: ~(fixnum->flonum fx)~

returns: the flonum representation closest to fx

procedure: ~(real->flonum real)~

returns: the flonum representation closest to real

libraries: (rnrs arithmetic flonums), (rnrs)


fixnum->flonum is a restricted variant of inexact. real->flonum is a restricted variant of inexact when the input is an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest flonum.

(fixnum->flonum 0) => 0.0
(fixnum->flonum 13) => 13.0

(real->flonum -1/2) => -0.5
(real->flonum 1s3) => 1000.0

** Section 6.7. Characters

Characters are atomic objects representing letters, digits, special symbols such as $ or -, and certain nongraphic control characters such as space and newline. Characters are written with a #\ prefix. For most characters, the prefix is followed by the character itself. The written character representation of the letter A, for example, is #\A. The characters newline, space, and tab may be written in this manner as well, but they can be written more clearly as #\newline, #\space, and #\tab. Other character names are supported as well, as defined by the grammar for character objects on page 457. Any Unicode character may be written with the syntax #\xn, where n consists of one or more hexadecimal digits and represents a valid Unicode scalar value.

This section describes the operations that deal primarily with characters. See also the following section on strings and Chapter 7 on input and output for other operations relating to characters.

procedure: ~(char=? char1 char2 char3 ...)~

procedure: ~(char<? char1 char2 char3 ...)~

procedure: ~(char>? char1 char2 char3 ...)~

procedure: ~(char<=? char1 char2 char3 ...)~

procedure: ~(char>=? char1 char2 char3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs base), (rnrs)


These predicates behave in a similar manner to the numeric predicates =, <, >, <=, and >=. For example, char=? returns #t when its arguments are equivalent characters, and char<? returns #t when its arguments are monotonically increasing character (Unicode scalar) values.

(char>? #\a #\b) => #f
(char<? #\a #\b) => #t
(char<? #\a #\b #\c) => #t
(let ([c #\r])
  (char<=? #\a c #\z)) => #t
(char<=? #\Z #\W) => #f
(char=? #\+ #\+) => #t

procedure: ~(char-ci=? char1 char2 char3 ...)~

procedure: ~(char-ci<? char1 char2 char3 ...)~

procedure: ~(char-ci>? char1 char2 char3 ...)~

procedure: ~(char-ci<=? char1 char2 char3 ...)~

procedure: ~(char-ci>=? char1 char2 char3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs unicode), (rnrs)


These predicates are identical to the predicates char=?, char<?, char>?, char<=?, and char>=? except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, char=? considers #\a and #\A to be distinct values; char-ci=? does not.

(char-ci<? #\a #\B) => #t
(char-ci=? #\W #\w) => #t
(char-ci=? #\= #\+) => #f
(let ([c #\R])
  (list (char<=? #\a c #\z)
        (char-ci<=? #\a c #\z))) => (#f #t)

procedure: ~(char-alphabetic? char)~

returns: #t if char is a letter, #f otherwise

procedure: ~(char-numeric? char)~

returns: #t if char is a digit, #f otherwise

procedure: ~(char-whitespace? char)~

returns: #t if char is whitespace, #f otherwise

libraries: (rnrs unicode), (rnrs)


A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space" property.

(char-alphabetic? #\a) => #t
(char-alphabetic? #\T) => #t
(char-alphabetic? #\8) => #f
(char-alphabetic? #\$) => #f

(char-numeric? #\7) => #t
(char-numeric? #\2) => #t
(char-numeric? #\X) => #f
(char-numeric? #\space) => #f

(char-whitespace? #\space) => #t
(char-whitespace? #\newline) => #t
(char-whitespace? #\Z) => #f

procedure: ~(char-lower-case? char)~

returns: #t if char is lower case, #f otherwise

procedure: ~(char-upper-case? char)~

returns: #t if char is upper case, #f otherwise

procedure: ~(char-title-case? char)~

returns: #t if char is title case, #f otherwise

libraries: (rnrs unicode), (rnrs)


A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property, and title-case if it is in the Lt general category.

(char-lower-case? #\r) => #t
(char-lower-case? #\R) => #f

(char-upper-case? #\r) => #f
(char-upper-case? #\R) => #t

(char-title-case? #\I) => #f
(char-title-case? #\x01C5) => #t

procedure: ~(char-general-category char)~

returns: a symbol representing the Unicode general category of char

libraries: (rnrs unicode), (rnrs)


The return value is one of the symbols Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Ps, Pe, Pi, Pf, Pd, Pc, Po, Sc, Sm, Sk, So, Zs, Zp, Zl, Cc, Cf, Cs, Co, or Cn.

(char-general-category #\a) => Ll
(char-general-category #\space) => Zs
(char-general-category #\x_10FFFF) => Cn  

procedure: ~(char-upcase char)~

returns: the upper-case character counterpart of char

libraries: (rnrs unicode), (rnrs)


If char is a lower- or title-case character and has a single upper-case counterpart, char-upcase returns the upper-case counterpart. Otherwise char-upcase returns char.

(char-upcase #\g) => #\G
(char-upcase #\G) => #\G
(char-upcase #\7) => #\7
(char-upcase #\=>) <graphic> #\<graphic>

procedure: ~(char-downcase char)~

returns: the lower-case character equivalent of char

libraries: (rnrs unicode), (rnrs)


If char is an upper- or title-case character and has a single lower-case counterpart, char-downcase returns the lower-case counterpart. Otherwise char-downcase returns char.

(char-downcase #\g) => #\g
(char-downcase #\G) => #\g
(char-downcase #\7) => #\7
(char-downcase #\=>) <graphic> #\<graphic>

procedure: ~(char-titlecase char)~

returns: the title-case character equivalent of char

libraries: (rnrs unicode), (rnrs)


If char is an upper- or lower-case character and has a single title-case counterpart, char-titlecase returns the title-case counterpart. Otherwise, if it is not a title-case character, has no single title-case counterpart, but does have a single upper-case counterpart, char-titlecase returns the upper-case counterpart. Otherwise char-titlecase returns char.

(char-titlecase #\g) => #\G
(char-titlecase #\G) => #\G
(char-titlecase #\7) => #\7
(char-titlecase #\=>) <graphic> #\<graphic>

procedure: ~(char-foldcase char)~

returns: the case-folded character equivalent of char

libraries: (rnrs unicode), (rnrs)


If char has a case-folded counterpart, char-foldcase returns the case-folded counterpart. Otherwise, char-foldcase returns char. For most characters, (char-foldcase char) 等价于 (char-downcase (char-upcase char)), but for Turkic İ and ı, char-foldcase acts as the identity.

(char-foldcase #\g) => #\g
(char-foldcase #\G) => #\g
(char-foldcase #\7) => #\7
(char-foldcase #\=>) <graphic> #\<graphic>

procedure: ~(char->integer char)~

returns: the Unicode scalar value of char as an exact integer

libraries: (rnrs base), (rnrs)


(char->integer #\newline) => 10
(char->integer #\space) => 32
(- (char->integer #\Z) (char->integer #\A)) => 25

procedure: ~(integer->char n)~

returns: the character corresponding to the Unicode scalar value n

libraries: (rnrs base), (rnrs)


n must be an exact integer and a valid Unicode scalar value, i.e., => or <graphic>.

(integer->char 48) => #\0
(integer->char #x3BB) => #\<graphic>

** Section 6.8. Strings

Strings are sequences of characters and are often used as messages, character buffers, or containers for blocks of text. Scheme provides operations for creating strings, extracting characters from strings, obtaining substrings, concatenating strings, and altering the contents of strings.

A string is written as a sequence of characters enclosed in double quotes, e.g., "hi there". A double quote may be introduced into a string by preceding it by a backward slash, e.g., "two \"quotes\" within". A backward slash may also be included by preceding it with a backward slash, e.g., "a \\slash". Various special characters can be inserted with other two-character sequences, e.g., \n for newline, \r for carriage return, and \t for tab. Any Unicode character may be inserted with the syntax #\xn;, where n consists of one or more hexadecimal digits and represents a valid Unicode scalar value. A grammar defining the precise syntax of strings is given on page 458.

Strings are indexed by exact nonnegative integers, and the index of the first element of any string is 0. The highest valid index for a given string is one less than its length.

procedure: ~(string=? string1 string2 string3 ...)~

procedure: ~(string<? string1 string2 string3 ...)~

procedure: ~(string>? string1 string2 string3 ...)~

procedure: ~(string<=? string1 string2 string3 ...)~

procedure: ~(string>=? string1 string2 string3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs base), (rnrs)


As with =, <, >, <=, and >=, these predicates express relationships among all of the arguments. For example, string>? determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates char=? and char<?. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to char=?. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by char=?) determines which string is lexicographically less than the other, according to char<?.

Two-argument string=? may be defined without error checks as follows.

(define string=?
  (lambda (s1 s2)
    (let ([n (string-length s1)])
      (and (= (string-length s2) n)
           (let loop ([i 0])
             (or (= i n)
                 (and (char=? (string-ref s1 i) (string-ref s2 i))
                      (loop (+ i 1)))))))))

Two-argument string<? may be defined without error checks as follows.

(define string<?
  (lambda (s1 s2)
    (let ([n1 (string-length s1)] [n2 (string-length s2)])
      (let loop ([i 0])
        (and (not (= i n2))
             (or (= i n1)
                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
                   (or (char<? c1 c2)
                       (and (char=? c1 c2)
                            (loop (+ i 1)))))))))))

These definitions may be extended straightforwardly to support three or more arguments. string<=?, string>?, and string>=? may be defined similarly.

(string=? "mom" "mom") => #t
(string<? "mom" "mommy") => #t
(string>? "Dad" "Dad") => #f
(string=? "Mom and Dad" "mom and dad") => #f
(string<? "a" "b" "c") => #t

procedure: ~(string-ci=? string1 string2 string3 ...)~

procedure: ~(string-ci<? string1 string2 string3 ...)~

procedure: ~(string-ci>? string1 string2 string3 ...)~

procedure: ~(string-ci<=? string1 string2 string3 ...)~

procedure: ~(string-ci>=? string1 string2 string3 ...)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs unicode), (rnrs)


These predicates are identical to string=?, string<?, string>?, string<=?, and string>=? except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

(string-ci=? "Mom and Dad" "mom and dad") => #t
(string-ci<=? "say what" "Say What!?") => #t
(string-ci>? "N" "m" "L" "k") => #t
(string-ci=? "Straße" "Strasse") => #t

procedure: ~(string char ...)~

returns: a string containing the characters char ...

libraries: (rnrs base), (rnrs)


(string) => ""
(string #\a #\b #\c) => "abc"
(string #\H #\E #\Y #\!) => "HEY!"

procedure: ~(make-string n)~

procedure: ~(make-string n char)~

returns: a string of length n

libraries: (rnrs base), (rnrs)


n must be an exact nonnegative integer. If char is supplied, the string is filled with n occurrences of char, otherwise the characters contained in the string are unspecified.

(make-string 0) => ""
(make-string 0 #\x) => ""
(make-string 5 #\x) => "xxxxx"

procedure: ~(string-length string)~

returns: the number of characters in string

libraries: (rnrs base), (rnrs)


The length of a string is always an exact nonnegative integer.

(string-length "abc") => 3
(string-length "") => 0
(string-length "hi there") => 8
(string-length (make-string 1000000)) => 1000000

procedure: ~(string-ref string n)~

returns: the nth character (zero-based) of string

libraries: (rnrs base), (rnrs)


n must be an exact nonnegative integer less than the length of string.

(string-ref "hi there" 0) => #\h
(string-ref "hi there" 5) => #\e

procedure: ~(string-set! string n char)~

returns: unspecified

libraries: (rnrs mutable-strings)


n must be an exact nonnegative integer less than the length of string. string-set! changes the nth element of string to char.

(let ([str (string-copy "hi three")])
  (string-set! str 5 #\e)
  (string-set! str 6 #\r)
  str) => "hi there"

procedure: ~(string-copy string)~

returns: a new copy of string

libraries: (rnrs base), (rnrs)


This procedure creates a new string with the same length and contents as string.

(string-copy "abc") => "abc"

(let ([str "abc"])
  (eq? str (string-copy str))) => #f

procedure: ~(string-append string ...)~

returns: a new string formed by concatenating the strings string ...

libraries: (rnrs base), (rnrs)


(string-append) => ""
(string-append "abc" "def") => "abcdef"
(string-append "Hey " "you " "there!") => "Hey you there!"

The following implementation of string-append recurs down the list of strings to compute the total length, then allocates the new string, then fills it up as it unwinds the recursion.

(define string-append
  (lambda args
    (let f ([ls args] [n 0])
      (if (null? ls)
          (make-string n)
          (let* ([s1 (car ls)]
                 [m (string-length s1)]
                 [s2 (f (cdr ls) (+ n m))])
            (do ([i 0 (+ i 1)] [j n (+ j 1)])
                ((= i m) s2)
              (string-set! s2 j (string-ref s1 i))))))))

procedure: ~(substring string start end)~

returns: a copy of string from start (inclusive) to end (exclusive)

libraries: (rnrs base), (rnrs)


start and end must be exact nonnegative integers; start must be less than or equal to end, while end must be less than or equal to the length of string. If end = start, a string of length zero is returned. substring may be defined without error checks as follows.

(define substring
  (lambda (s1 m n)
    (let ([s2 (make-string (- n m))])
      (do ([j 0 (+ j 1)] [i m (+ i 1)])
          ((= i n) s2)
        (string-set! s2 j (string-ref s1 i))))))

(substring "hi there" 0 1) => "h"
(substring "hi there" 3 6) => "the"
(substring "hi there" 5 5) => ""

(let ([str "hi there"])
  (let ([end (string-length str)])
    (substring str 0 end))) => "hi there"

procedure: ~(string-fill! string char)~

returns: unspecified

libraries: (rnrs mutable-strings)


string-fill! sets every character in string to char.

(let ([str (string-copy "sleepy")])
  (string-fill! str #\Z)
  str) => "ZZZZZZ"

string-fill! might be defined as follows:

(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (do ([i 0 (+ i 1)])
          ((= i n))
          (string-set! s i c)))))

An alternative definition is given on page 276.

procedure: ~(string-upcase string)~

returns: the upper-case equivalent of string

procedure: ~(string-downcase string)~

returns: the lower-case equivalent of string

procedure: ~(string-foldcase string)~

returns: the case-folded equivalent of string

procedure: ~(string-titlecase string)~

returns: the title-case equivalent of string

libraries: (rnrs unicode), (rnrs)


These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of string. If the result string is the same as string (by string=?), string or a copy of string may be returned. Otherwise, the result string is newly allocated. string-foldcase does not use the special mappings for Turkic languages.

string-titlecase converts the first cased character of each word in string to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode St and ard Annex #29 [8].

(string-upcase "Hi") => "HI"
(string-downcase "Hi") => "hi"
(string-foldcase "Hi") => "hi"

(string-upcase "Straße") => "STRASSE"
(string-downcase "Straße") => "straße"
(string-foldcase "Straße") => "strasse"
(string-downcase "STRASSE")  => "strasse"

(string-downcase "=>") <graphic> "<graphic>"

(string-titlecase "kNock KNoCK") => "Knock Knock"
(string-titlecase "who's there?") => "Who's There?"
(string-titlecase "r6rs") => "R6rs"
(string-titlecase "R6RS") => "R6rs"

procedure: ~(string-normalize-nfd string)~

returns: the Unicode normalized form D of string

procedure: ~(string-normalize-nfkd string)~

returns: the Unicode normalized form KD of string

procedure: ~(string-normalize-nfc string)~

returns: the Unicode normalized form C of string

procedure: ~(string-normalize-nfkc string)~

returns: the Unicode normalized form KC of string

libraries: (rnrs unicode), (rnrs)


If the result string is the same as string (by string=?), string or a copy of string may be returned. Otherwise, the result string is newly allocated.

(string-normalize-nfd "\xE9;") => "e\x301;"
(string-normalize-nfc "\xE9;") => "\xE9;"
(string-normalize-nfd "\x65;\x301;") => "e\x301;"
(string-normalize-nfc "\x65;\x301;") => "\xE9;"

procedure: ~(string->list string)~

returns: a list of the characters in string

libraries: (rnrs base), (rnrs)


string->list allows a string to be converted into a list, so that Scheme's list-processing operations may be applied to the processing of strings. string->list may be defined without error checks as follows.

(define string->list
  (lambda (s)
    (do ([i (- (string-length s) 1) (- i 1)]
         [ls '() (cons (string-ref s i) ls)])
        ((< i 0) ls))))

(string->list "") => ()
(string->list "abc") => (#\a #\b #\c)
(apply char<? (string->list "abc")) => #t
(map char-upcase (string->list "abc")) => (#\A #\B #\C)

procedure: ~(list->string list)~

returns: a string of the characters in list

libraries: (rnrs base), (rnrs)


list must consist entirely of characters.

list->string is the functional inverse of string->list. A program might use both procedures together, first converting a string into a list, then operating on this list to produce a new list, and finally converting the new list back into a string.

list->string may be defined without error checks as follows.

(define list->string
  (lambda (ls)
    (let ([s (make-string (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (string-set! s i (car ls))))))

(list->string '()) => ""
(list->string '(#\a #\b #\c)) => "abc"
(list->string
  (map char-upcase
       (string->list "abc"))) => "ABC"

** Section 6.9. Vectors

Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time. The length of a vector is the number of elements it contains. Vectors are indexed by exact nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given vector is one less than its length.

As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of object.

A vector is written as a sequence of objects separated by whitespace, preceded by the prefix #( and followed by ). For example, a vector consisting of the elements a, b, and c would be written #(a b c).

procedure: ~(vector obj ...)~

returns: a vector of the objects obj ...

libraries: (rnrs base), (rnrs)


(vector) => #()
(vector 'a 'b 'c) => #(a b c)

procedure: ~(make-vector n)~

procedure: ~(make-vector n obj)~

returns: a vector of length n

libraries: (rnrs base), (rnrs)


n must be an exact nonnegative integer. If obj is supplied, each element of the vector is filled with obj; otherwise, the elements are unspecified.

(make-vector 0) => #()
(make-vector 0 '#(a)) => #()
(make-vector 5 '#(a)) => #(#(a) #(a) #(a) #(a) #(a))

procedure: ~(vector-length vector)~

returns: the number of elements in vector

libraries: (rnrs base), (rnrs)


The length of a vector is always an exact nonnegative integer.

(vector-length '#()) => 0
(vector-length '#(a b c)) => 3
(vector-length (vector 1 '(2) 3 '#(4 5))) => 4
(vector-length (make-vector 300)) => 300

procedure: ~(vector-ref vector n)~

returns: the nth element (zero-based) of vector

libraries: (rnrs base), (rnrs)


n must be an exact nonnegative integer less than the length of vector.

(vector-ref '#(a b c) 0) => a
(vector-ref '#(a b c) 1) => b
(vector-ref '#(x y z w) 3) => w

procedure: ~(vector-set! vector n obj)~

returns: unspecified

libraries: (rnrs base), (rnrs)


n must be an exact nonnegative integer less than the length of vector. vector-set! changes the nth element of vector to obj.

(let ([v (vector 'a 'b 'c 'd 'e)])
  (vector-set! v 2 'x)
  v) => #(a b x d e)

procedure: ~(vector-fill! vector obj)~

returns: unspecified

libraries: (rnrs base), (rnrs)


vector-fill! replaces each element of vector with obj. It may be defined without error checks as follows.

(define vector-fill!
  (lambda (v x)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i x)))))

(let ([v (vector 1 2 3)])
  (vector-fill! v 0)
  v) => #(0 0 0)

procedure: ~(vector->list vector)~

returns: a list of the elements of vector

libraries: (rnrs base), (rnrs)


vector->list provides a convenient method for applying list-processing operations to vectors. It may be defined without error checks as follows.

(define vector->list
  (lambda (s)
    (do ([i (- (vector-length s) 1) (- i 1)]
         [ls '() (cons (vector-ref s i) ls)])
        ((< i 0) ls))))

(vector->list (vector)) => ()
(vector->list '#(a b c)) => (a b c)

(let ((v '#(1 2 3 4 5)))
  (apply * (vector->list v))) => 120

procedure: ~(list->vector list)~

returns: a vector of the elements of list

libraries: (rnrs base), (rnrs)


list->vector is the functional inverse of vector->list. The two procedures are often used in combination to take advantage of a list-processing operation. A vector may be converted to a list with vector->list, this list processed in some manner to produce a new list, and the new list converted back into a vector with list->vector.

list->vector may be defined without error checks as follows.

(define list->vector
  (lambda (ls)
    (let ([s (make-vector (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (vector-set! s i (car ls))))))

(list->vector '()) => #()
(list->vector '(a b c)) => #(a b c)

(let ([v '#(1 2 3 4 5)])
  (let ([ls (vector->list v)])
    (list->vector (map * ls ls)))) => #(1 4 9 16 25)

procedure: ~(vector-sort predicate vector)~

returns: a vector containing the elements of vector, sorted according to predicate

procedure: ~(vector-sort! predicate vector)~

returns: unspecified

libraries: (rnrs sorting), (rnrs)


predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its second in the sorted vector. That is, if predicate is applied to two elements x and y, where x appears after y in the input vector, the predicate should return true only if x should appear before y in the output vector. If this constraint is met, vector-sort performs a stable sort, i.e., two elements are reordered only when necessary according to predicate. vector-sort! performs the sort destructively and does not necessarily perform a stable sort. Duplicate elements are not removed. predicate should not have any side effects.

vector-sort may call predicate up to nlogn times, where n is the length of vector, while vector-sort! may call the predicate up to n2 times. The looser bound for vector-sort! allows an implementation to use a quicksort algorithm, which may be faster in some cases than algorithms that have the tighter nlogn bound.

(vector-sort < '#(3 4 2 1 2 5)) => #(1 2 2 3 4 5)
(vector-sort > '#(0.5 1/2)) => #(0.5 1/2)
(vector-sort > '#(1/2 0.5)) => #(1/2 0.5)

(let ([v (vector 3 4 2 1 2 5)])
  (vector-sort! < v)
  v) => #(1 2 2 3 4 5)

** Section 6.10. Bytevectors

Bytevectors are vectors of raw binary data. Although nominally organized as a sequence of exact unsigned 8-bit integers, a bytevector can be interpreted as a sequence of exact signed 8-bit integers, exact signed or unsigned 16-bit, 32-bit, 64-bit, or arbitrary-precision integers, IEEE single or double floating-point numbers, or arbitrary combinations of the above.

The length of a bytevector is the number of 8-bit bytes it stores, and indices into a bytevector are always given as byte offsets. Any data element may be aligned at any byte offset, regardless of the underlying hardware's alignment requirements, and may be represented using a specified endianness (参见下文) that differs from that prescribed by the hardware. Special, typically more efficient operators are provided for 16-, 32-, and 64-bit integers and single and double floats that are in their native format, i.e,. with the endianness of the underlying hardware and stored at an index that is a multiple of the size in bytes of the integer or float.

The endianness of a multi-byte data value determines how it is laid out in memory. In big-endian format, the value is laid out with the more significant bytes at lower indices, while in little-endian format, the value is laid out with the more significant bytes at higher indices. When a bytevector procedure accepts an endianness argument, the argument may be the symbol big, representing the big-endian format, or the symbol little, representing the little-endian format. Implementations may extend these procedures to accept other endianness symbols. The native endianness of the implementation may be obtained via the procedure native-endianness.

Bytevectors are written with the #vu8( prefix in place of the #( prefix for vectors, e.g., #vu8(1 2 3). The elements of a bytevector specified in this manner are always given as 8-bit unsigned exact integers, i.e., integers from 0 to 255 inclusive, written using any valid syntax for such numbers. Like strings, bytevectors are self-evaluating, so they need not be quoted.

'#vu8(1 2 3) => #vu8(1 2 3)
#vu8(1 2 3) => #vu8(1 2 3)
#vu8(#x3f #x7f #xbf #xff) => #vu8(63 127 191 255)

syntax: (endianness symbol)

returns: symbol

libraries: (rnrs bytevectors), (rnrs)


symbol must be the symbol little, the symbol big, or some other symbol recognized by the implementation as an endianness symbol. It is a syntax violation if symbol is not a symbol or if it is not recognized by the implementation as an endianness symbol.

(endianness little) => little
(endianness big) => big
(endianness "spam") => exception

procedure: ~(native-endianness)~

returns: a symbol naming the implementation's native endianness

libraries: (rnrs bytevectors), (rnrs)


The return value is the symbol little, the symbol big, or some other endianness symbol recognized by the implementation. It typically reflects the endianness of the underlying hardware.

(symbol? (native-endianness)) => #t

procedure: ~(make-bytevector n)~

procedure: ~(make-bytevector n fill)~

returns: a new bytevector of length n

libraries: (rnrs bytevectors), (rnrs)


If fill is supplied, each element of the bytevector is initialized to fill; otherwise, the elements are unspecified. The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

(make-bytevector 0) => #vu8()
(make-bytevector 0 7) => #vu8()
(make-bytevector 5 7) => #vu8(7 7 7 7 7)
(make-bytevector 5 -7) => #vu8(249 249 249 249 249)

procedure: ~(bytevector-length bytevector)~

returns: the length of bytevector in 8-bit bytes

libraries: (rnrs bytevectors), (rnrs)


(bytevector-length #vu8()) => 0
(bytevector-length #vu8(1 2 3)) => 3
(bytevector-length (make-bytevector 300)) => 300

procedure: ~(bytevector=? bytevector1 bytevector2)~

returns: #t if the relation holds, #f otherwise

libraries: (rnrs bytevectors), (rnrs)


Two bytevectors are equal by bytevector=? if and only if they have the same length and same contents.

(bytevector=? #vu8() #vu8()) => #t
(bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) => #t
(bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) => #f
(bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) => #f

procedure: ~(bytevector-fill! bytevector fill)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

bytevector-fill! replaces each element of bytevector with fill.

(let ([v (make-bytevector 6)])
  (bytevector-fill! v 255)
  v) => #vu8(255 255 255 255 255 255)

(let ([v (make-bytevector 6)])
  (bytevector-fill! v -128)
  v) => #vu8(128 128 128 128 128 128)

procedure: ~(bytevector-copy bytevector)~

returns: a new bytevector that is a copy of bytevector

libraries: (rnrs bytevectors), (rnrs)


bytevector-copy creates a new bytevector with the same length and contents as bytevector.

(bytevector-copy #vu8(1 127 128 255)) => #vu8(1 127 128 255)

(let ([v #vu8(1 127 128 255)])
  (eq? v (bytevector-copy v))) => #f

procedure: ~(bytevector-copy! src src-start dst dst-start n)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


src and dst must be bytevectors. src-start, dst-start, and n must be exact nonnegative integers. The sum of src-start and n must not exceed the length of src, and the sum of dst-start and n must not exceed the length of dst.

bytevector-copy! overwrites the n bytes of dst starting at dst-start with the n bytes of src starting at src-start. This works even if dst is the same bytevector as src and the source and destination locations overlap. That is, the destination is filled with the bytes that appeared at the source before the operation began.

(define v1 #vu8(31 63 95 127 159 191 223 255))
(define v2 (make-bytevector 10 0))

(bytevector-copy! v1 2 v2 1 4)
v2 => #vu8(0 95 127 159 191 0 0 0 0 0)
 
(bytevector-copy! v1 5 v2 7 3)
v2 => #vu8(0 95 127 159 191 0 0 191 223 255)
 
(bytevector-copy! v2 3 v2 0 6)
v2 => #vu8(159 191 0 0 191 223 0 191 223 255)
 
(bytevector-copy! v2 0 v2 1 9)
v2 => #vu8(159 159 191 0 0 191 223 0 191 223)

procedure: ~(bytevector-u8-ref bytevector n)~

returns: the 8-bit unsigned byte at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer less than the length of bytevector.

The value is returned as an exact 8-bit unsigned integer, i.e., a value in the range 0 to 255 inclusive.

(bytevector-u8-ref #vu8(1 127 128 255) 0) => 1
(bytevector-u8-ref #vu8(1 127 128 255) 2) => 128
(bytevector-u8-ref #vu8(1 127 128 255) 3) => 255

procedure: ~(bytevector-s8-ref bytevector n)~

returns: the 8-bit signed byte at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer less than the length of bytevector.

The value returned is an exact 8-bit signed integer, i.e., a value in the range -128 to 127 inclusive, and is the equivalent of the stored value treated as a two's complement value.

(bytevector-s8-ref #vu8(1 127 128 255) 0) => 1
(bytevector-s8-ref #vu8(1 127 128 255) 1) => 127
(bytevector-s8-ref #vu8(1 127 128 255) 2) => -128
(bytevector-s8-ref #vu8(1 127 128 255) 3) => -1

procedure: ~(bytevector-u8-set! bytevector n u8)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer less than the length of bytevector. u8 must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive.

bytevector-u8-set! changes the 8-bit value at index n (zero-based) of bytevector to u8.

(let ([v (make-bytevector 5 -1)])
  (bytevector-u8-set! v 2 128)
  v) => #vu8(255 255 128 255 255)

procedure: ~(bytevector-s8-set! bytevector n s8)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer less than the length of bytevector. s8 must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive.

bytevector-s8-set! changes the 8-bit value at index n (zero-based) of bytevector to the two's complement equivalent of s8.

(let ([v (make-bytevector 4 0)])
  (bytevector-s8-set! v 1 100)
  (bytevector-s8-set! v 2 -100)
  v) => #vu8(0 100 156 0)

procedure: ~(bytevector->u8-list bytevector)~

returns: a list of the 8-bit unsigned elements of bytevector

libraries: (rnrs bytevectors), (rnrs)


(bytevector->u8-list (make-bytevector 0)) => ()
(bytevector->u8-list #vu8(1 127 128 255)) => (1 127 128 255)

(let ([v #vu8(1 2 3 255)])
  (apply * (bytevector->u8-list v))) => 1530

procedure: ~(u8-list->bytevector list)~

returns: a new bytevector of the elements of list

libraries: (rnrs bytevectors), (rnrs)


list must consist entirely of exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.

(u8-list->bytevector '()) => #vu8()
(u8-list->bytevector '(1 127 128 255)) => #vu8(1 127 128 255)

(let ([v #vu8(1 2 3 4 5)])
  (let ([ls (bytevector->u8-list v)])
    (u8-list->bytevector (map * ls ls)))) => #vu8(1 4 9 16 25)

procedure: ~(bytevector-u16-native-ref bytevector n)~

returns: the 16-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s16-native-ref bytevector n)~

returns: the 16-bit signed integer at index n (zero-based) of bytevector

procedure: ~(bytevector-u32-native-ref bytevector n)~

returns: the 32-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s32-native-ref bytevector n)~

returns: the 32-bit signed integer at index n (zero-based) of bytevector

procedure: ~(bytevector-u64-native-ref bytevector n)~

returns: the 64-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s64-native-ref bytevector n)~

returns: the 64-bit signed integer at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

(define v #vu8(#x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98))

If native endianness is big:

(bytevector-u16-native-ref v 2) => #xfe56
(bytevector-s16-native-ref v 2) => #x-1aa
(bytevector-s16-native-ref v 6) => #x7898

(bytevector-u32-native-ref v 0) => #x_1234fe56
(bytevector-s32-native-ref v 0) => #x_1234fe56
(bytevector-s32-native-ref v 4) => #x-23458768

(bytevector-u64-native-ref v 0) => #x_1234fe56dcba7898
(bytevector-s64-native-ref v 0) => #x_1234fe56dcba7898

If native endianness is little:

(bytevector-u16-native-ref v 2) => #x56fe
(bytevector-s16-native-ref v 2) => #x56fe
(bytevector-s16-native-ref v 6) => #x-6788

(bytevector-u32-native-ref v 0) => #x56fe3412
(bytevector-s32-native-ref v 0) => #x56fe3412
(bytevector-s32-native-ref v 4) => #x-67874524

(bytevector-u64-native-ref v 0) => #x9878badc56fe3412
(bytevector-s64-native-ref v 0) => #x-67874523a901cbee

procedure: ~(bytevector-u16-native-set! bytevector n u16)~

procedure: ~(bytevector-s16-native-set! bytevector n s16)~

procedure: ~(bytevector-u32-native-set! bytevector n u32)~

procedure: ~(bytevector-s32-native-set! bytevector n s32)~

procedure: ~(bytevector-u64-native-set! bytevector n u64)~

procedure: ~(bytevector-s64-native-set! bytevector n s64)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of n and the number of bytes occupied by the value must not exceed the length bytevector. u16 must be a 16-bit unsigned value, i.e., a value in the range 0 to 216 - 1 inclusive; s16 must be a 16-bit signed value, i.e., a value in the range -215 to 215 - 1 inclusive; u32 must be a 32-bit unsigned value, i.e., a value in the range 0 to 232 - 1 inclusive; s32 must be a 32-bit signed value, i.e., a value in the range -231 to 231 - 1 inclusive; u64 must be a 64-bit unsigned value, i.e., a value in the range 0 to 264 - 1 inclusive; and s64 must be a 64-bit signed value, i.e., a value in the range -263 to 263 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent.

(define v (make-bytevector 8 0))
(bytevector-u16-native-set! v 0 #xfe56)
(bytevector-s16-native-set! v 2 #x-1aa)
(bytevector-s16-native-set! v 4 #x7898)

If native endianness is big:

v => #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)

If native endianness is little:

v => #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)

(define v (make-bytevector 16 0))
(bytevector-u32-native-set! v 0 #x_1234fe56)
(bytevector-s32-native-set! v 4 #x_1234fe56)
(bytevector-s32-native-set! v 8 #x-23458768)

If native endianness is big:

v => #vu8(#x_12 #x34 #xfe #x56 #x_12 #x34 #xfe #x56
        #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)

If native endianness is little:

v => #vu8(#x56 #xfe #x34 #x_12 #x56 #xfe #x34 #x_12
        #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)

(define v (make-bytevector 24 0))
(bytevector-u64-native-set! v 0 #x_1234fe56dcba7898)
(bytevector-s64-native-set! v 8 #x_1234fe56dcba7898)
(bytevector-s64-native-set! v 16 #x-67874523a901cbee)

If native endianness is big:

v => #vu8(#x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98
        #x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x_12)

If native endianness is little:

v => #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x_12
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x_12
        #x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98)

procedure: ~(bytevector-u16-ref bytevector n eness)~

returns: the 16-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s16-ref bytevector n eness)~

returns: the 16-bit signed integer at index n (zero-based) of bytevector

procedure: ~(bytevector-u32-ref bytevector n eness)~

returns: the 32-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s32-ref bytevector n eness)~

returns: the 32-bit signed integer at index n (zero-based) of bytevector

procedure: ~(bytevector-u64-ref bytevector n eness)~

returns: the 64-bit unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-s64-ref bytevector n eness)~

returns: the 64-bit signed integer at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

(define v #vu8(#x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))
(bytevector-u16-ref v 0 (endianness big)) => #x_1234
(bytevector-s16-ref v 1 (endianness big)) => #x34fe
(bytevector-s16-ref v 5 (endianness big)) => #x-4588

(bytevector-u32-ref v 2 'big) => #xfe56dcba
(bytevector-s32-ref v 3 'big) => #x56dcba78
(bytevector-s32-ref v 4 'big) => #x-23458768

(bytevector-u64-ref v 0 'big) => #x_1234fe56dcba7898
(bytevector-s64-ref v 1 'big) => #x34fe56dcba78989a

(bytevector-u16-ref v 0 (endianness little)) => #x3412
(bytevector-s16-ref v 1 (endianness little)) => #x-1cc
(bytevector-s16-ref v 5 (endianness little)) => #x78ba

(bytevector-u32-ref v 2 'little) => #xbadc56fe
(bytevector-s32-ref v 3 'little) => #x78badc56
(bytevector-s32-ref v 4 'little) => #x-67874524

(bytevector-u64-ref v 0 'little) => #x9878badc56fe3412
(bytevector-s64-ref v 1 'little) => #x-6567874523a901cc

procedure: ~(bytevector-u16-set! bytevector n u16 eness)~

procedure: ~(bytevector-s16-set! bytevector n s16 eness)~

procedure: ~(bytevector-u32-set! bytevector n u32 eness)~

procedure: ~(bytevector-s32-set! bytevector n s32 eness)~

procedure: ~(bytevector-u64-set! bytevector n u64 eness)~

procedure: ~(bytevector-s64-set! bytevector n s64 eness)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. u16 must be a 16-bit unsigned value, i.e., a value in the range 0 to 216 - 1 inclusive; s16 must be a 16-bit signed value, i.e., a value in the range -215 to 215 - 1 inclusive; u32 must be a 32-bit unsigned value, i.e., a value in the range 0 to 232 - 1 inclusive; s32 must be a 32-bit signed value, i.e., a value in the range -231 to 231 - 1 inclusive; u64 must be a 64-bit unsigned value, i.e., a value in the range 0 to 264 - 1 inclusive; and s64 must be a 64-bit signed value, i.e., a value in the range -263 to 263 - 1 inclusive. eness must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent.

(define v (make-bytevector 8 0))
(bytevector-u16-set! v 0 #xfe56 (endianness big))
(bytevector-s16-set! v 3 #x-1aa (endianness little))
(bytevector-s16-set! v 5 #x7898 (endianness big))
v => #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)

(define v (make-bytevector 16 0))
(bytevector-u32-set! v 0 #x_1234fe56 'little)
(bytevector-s32-set! v 6 #x_1234fe56 'big)
(bytevector-s32-set! v 11 #x-23458768 'little)
v => #vu8(#x56 #xfe #x34 #x_12 #x0 #x0
        #x_12 #x34 #xfe #x56 #x0
        #x98 #x78 #xba #xdc #x0)

(define v (make-bytevector 28 0))
(bytevector-u64-set! v 0 #x_1234fe56dcba7898 'little)
(bytevector-s64-set! v 10 #x_1234fe56dcba7898 'big)
(bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
v => #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x_12 #x0 #x0
        #x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0
        #x98 #x78 #xba #xdc #x56 #xfe #x34 #x_12 #x0)

procedure: ~(bytevector-uint-ref bytevector n eness size)~

returns: the size-byte unsigned integer at index n (zero-based) of bytevector

procedure: ~(bytevector-sint-ref bytevector n eness size)~

returns: the size-byte signed integer at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

(define v #vu8(#x_12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))

(bytevector-uint-ref v 0 'big 1) => #x_12
(bytevector-uint-ref v 0 'little 1) => #x_12
(bytevector-uint-ref v 1 'big 3) => #x34fe56
(bytevector-uint-ref v 2 'little 7) => #x9a9878badc56fe

(bytevector-sint-ref v 2 'big 1) => #x-02
(bytevector-sint-ref v 1 'little 6) => #x78badc56fe34
(bytevector-sint-ref v 2 'little 7) => #x-6567874523a902

(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) => -1

procedure: ~(bytevector-uint-set! bytevector n uint eness size)~

procedure: ~(bytevector-sint-set! bytevector n sint eness size)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. uint must be an exact integer in the range 0 to 2size·8 - 1 inclusive. sint must be an exact integer in the range -2size·8-1 to 2size·8-1 - 1 inclusive. eness must be a valid endianness symbol naming the endianness.

These procedures store the given value in the size bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent.

(define v (make-bytevector 5 0))
(bytevector-uint-set! v 1 #x_123456 (endianness big) 3)
v => #vu8(0 #x_12 #x34 #x56 0)

(define v (make-bytevector 7 -1))
(bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
v => #vu8(#xff 0 0 0 0 #x80 #xff)

procedure: ~(bytevector->uint-list bytevector eness size)~

returns: a new list of the size-byte unsigned elements of bytevector

procedure: ~(bytevector->sint-list bytevector eness size)~

returns: a new list of the size-byte signed elements of bytevector

libraries: (rnrs bytevectors), (rnrs)


eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies the number of bytes occupied by the value. It must be a value that evenly divides the length of bytevector.

(bytevector->uint-list (make-bytevector 0) 'little 3) => ()

(let ([v #vu8(1 2 3 4 5 6)])
  (bytevector->uint-list v 'big 3)) => (#x010203 #x040506)

(let ([v (make-bytevector 80 -1)])
  (bytevector->sint-list v 'big 20)) => (-1 -1 -1 -1)

procedure: ~(uint-list->bytevector list eness size)~

procedure: ~(sint-list->bytevector list eness size)~

returns: a new bytevector of the elements of list

libraries: (rnrs bytevectors), (rnrs)


eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies the number of bytes occupied by the value. For uint-list->bytevector, list must consist entirely of size-byte exact unsigned integers, i.e., values in the range 0 to 2size·8 - 1 inclusive. For sint-list->bytevector, list must consist entirely of size-byte exact signed integers, i.e., values in the range -2size·8-1 to 2size·8-1 - 1 inclusive. Each value occupies size bytes in the resulting bytevector, whose length is thus size times the length of list.

(uint-list->bytevector '() 'big 25) => #vu8()
(sint-list->bytevector '(0 -1) 'big 3) => #vu8(0 0 0 #xff #xff #xff)

(define (f size)
  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
                  (- (expt 2 (- (* 8 size) 1)) 1))])
    (sint-list->bytevector ls 'little size)))
(f 6) => #vu8(#x00 #x00 #x00 #x00 #x00 #x80
            #xff #xff #xff #xff #xff #x7f)

procedure: ~(bytevector-ieee-single-native-ref bytevector n)~

returns: the single floating-point value at index n (zero-based) of bytevector

procedure: ~(bytevector-ieee-double-native-ref bytevector n)~

returns: the double floating-point value at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed.

The return value is an inexact real number. Examples appear after the mutation operators below.

procedure: ~(bytevector-ieee-single-native-set! bytevector n x)~

procedure: ~(bytevector-ieee-double-native-set! bytevector n x)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed.

These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based) of bytevector.

(define v (make-bytevector 8 0))
(bytevector-ieee-single-native-set! v 0 .125)
(bytevector-ieee-single-native-set! v 4 -3/2)
(list
  (bytevector-ieee-single-native-ref v 0)
  (bytevector-ieee-single-native-ref v 4)) => (0.125 -1.5)

(bytevector-ieee-double-native-set! v 0 1e23)
(bytevector-ieee-double-native-ref v 0) => 1e23

procedure: ~(bytevector-ieee-single-ref bytevector n eness)~

returns: the single floating-point value at index n (zero-based) of bytevector

procedure: ~(bytevector-ieee-double-ref bytevector n eness)~

returns: the double floating-point value at index n (zero-based) of bytevector

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness.

The return value is an inexact real number. Examples appear after the mutation operators below.

procedure: ~(bytevector-ieee-single-set! bytevector n x eness)~

procedure: ~(bytevector-ieee-double-set! bytevector n x eness)~

returns: unspecified

libraries: (rnrs bytevectors), (rnrs)


n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness.

These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based) of bytevector.

(define v (make-bytevector 10 #xc7))
(bytevector-ieee-single-set! v 1 .125 'little)
(bytevector-ieee-single-set! v 6 -3/2 'big)
(list
  (bytevector-ieee-single-ref v 1 'little)
  (bytevector-ieee-single-ref v 6 'big)) => (0.125 -1.5)
v => #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)

(bytevector-ieee-double-set! v 1 1e23 'big)
(bytevector-ieee-double-ref v 1 'big) => 1e23

** Section 6.11. Symbols

Symbols are used for a variety of purposes as symbolic names in Scheme programs. Strings could be used for most of the same purposes, but an important characteristic of symbols makes comparisons between symbols much more efficient. This characteristic is that two symbols with the same name are identical in the sense of eq?. The reason is that the Scheme reader (invoked by get-datum and read) and the procedure string->symbol catalog symbols in an internal symbol table and always return the same symbol whenever the same name is encountered. Thus, no character-by-character comparison is needed, as would be needed to compare two strings.

The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers. This property also makes symbols useful for a variety of other purposes. For example, symbols might be used as messages passed between procedures, labels for list-structured records, or names for objects stored in an association list (see assq in Section 6.3).

Symbols are written without double quotes or other bracketing characters. Parentheses, double quotes, spaces, and most other characters with a special meaning to the Scheme reader are not allowed within the printed representation of a symbol. These and any other Unicode character may appear anywhere within the printed representation of a symbol with the syntax #\xn;, where n consists of one or more hexadecimal digits and represents a valid Unicode scalar value.

The grammar for symbols on page 458 gives a precise definition of the syntax of symbols.

procedure: ~(symbol=? symbol1 symbol2)~

returns: #t if the two symbols are the same, #f otherwise

libraries: (rnrs base), (rnrs)


Symbols can also be compared with eq?, which is typically more efficient than symbol=?.

(symbol=? 'a 'a) => #t
(symbol=? 'a (string->symbol "a")) => #t
(symbol=? 'a 'b) => #f

procedure: ~(string->symbol string)~

returns: a symbol whose name is string

libraries: (rnrs base), (rnrs)


string->symbol records all symbols it creates in an internal table that it shares with the system reader. If a symbol whose name 等价于 string (according to the predicate string=?) already exists in the table, this symbol is returned. Otherwise, a new symbol is created with string as its name; this symbol is entered into the table and returned.

The effect of modifying a string after it is used as an argument to string->symbol is unspecified.

(string->symbol "x") => x

(eq? (string->symbol "x") 'x) => #t
(eq? (string->symbol "X") 'x) => #f

(eq? (string->symbol "x")
     (string->symbol "x")) => #t

(string->symbol "()") => \x_28;\x_29;

procedure: ~(symbol->string symbol)~

returns: a string, the name of symbol

libraries: (rnrs base), (rnrs)


The string returned by symbol->string should be treated as immutable. Unpredictable behavior can result if a string passed to string->symbol is altered with string-set! or by any other means.

(symbol->string 'xyz) => "xyz"
(symbol->string 'Hi) => "Hi"
(symbol->string (string->symbol "()")) => "()"

** Section 6.12. Booleans

While every Scheme object has a truth value when used in a conditional context, with every object but #f counting as true, Scheme provides the dedicated true value #t for use when a value of an expression should convey nothing more than that it is true.

procedure: ~(boolean=? boolean1 boolean2)~

returns: #t if the two booleans are the same, #f otherwise

libraries: (rnrs base), (rnrs)


The boolean values #t and #f may also be compared with eq?, which is typically more efficient than boolean=?.

(boolean=? #t #t) => #t
(boolean=? #t #f) => #f
(boolean=? #t (< 3 4)) => #t

** Section 6.13. Hashtables

Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists (see page  165) but are typically much faster when large numbers of associations are involved.

procedure: ~(make-eq-hashtable)~

procedure: ~(make-eq-hashtable size)~

returns: a new mutable eq hashtable

libraries: (rnrs hashtables), (rnrs)


If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated.

An eq hashtable compares keys using the eq? (pointer equality) procedure and typically employs a hash function based on object addresses. Its hash and equivalence functions are suitable for any Scheme object.

(define ht1 (make-eq-hashtable))
(define ht2 (make-eq-hashtable 32))

procedure: ~(make-eqv-hashtable)~

procedure: ~(make-eqv-hashtable size)~

returns: a new mutable eqv hashtable

libraries: (rnrs hashtables), (rnrs)


If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated.

An eqv hashtable compares keys using the eqv? procedure and typically employs a hash function based on object addresses for objects that are identifiable with eq?. Its hash and equivalence functions are suitable for any Scheme object.

procedure: ~(make-hashtable hash equiv?)~

procedure: ~(make-hashtable hash equiv? size)~

returns: a new mutable hashtable

libraries: (rnrs hashtables), (rnrs)


hash and equiv? must be procedures. If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated.

The new hashtable computes hash values using hash and compares keys using equiv?, neither of which should modify the hashtable. equiv? should compare two keys and return false only if the two keys should be distinguished. hash should accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called with arguments that equiv? does not distinguish. The hash and equiv? procedures need not accept arbitrary inputs as long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are immutable as long as the keys are not modified while they have associations stored in the table. The hashtable operation may call hash and equiv? once, not at all, or multiple times for each hashtable operation.

(define ht (make-hashtable string-hash string=?))

procedure: ~(hashtable-mutable? hashtable)~

returns: #t if hashtable is mutable, #f otherwise

libraries: (rnrs hashtables), (rnrs)


Hashtables returned by one of the hashtable creation procedures above are mutable, but those created by hashtable-copy may be immutable. Immutable hashtables cannot be altered by any of the procedures hashtable-set!, hashtable-update!, hashtable-delete!, or hashtable-clear!.

(hashtable-mutable? (make-eq-hashtable)) => #t
(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) => #f

procedure: ~(hashtable-hash-function hashtable)~

returns: the hash function associated with hashtable

procedure: ~(hashtable-equivalence-function hashtable)~

returns: the equivalence function associated with hashtable

libraries: (rnrs hashtables), (rnrs)


hashtable-hash-function returns #f for eq and eqv hashtables.

(define ht (make-eq-hashtable))
(hashtable-hash-function ht) => #f
(eq? (hashtable-equivalence-function ht) eq?) => #t

(define ht (make-hashtable string-hash string=?))
(eq? (hashtable-hash-function ht) string-hash) => #t
(eq? (hashtable-equivalence-function ht) string=?) => #t

procedure: ~(equal-hash obj)~

procedure: ~(string-hash string)~

procedure: ~(string-ci-hash string)~

procedure: ~(symbol-hash symbol)~

returns: an exact nonnegative integer hash value

libraries: (rnrs hashtables), (rnrs)


These procedures are hash functions suitable for use with the appropriate Scheme predicate: equal? for equal-hash, string=? for string-hash, string-ci=? for string-ci-hash, and symbol=? (or eq?) for symbol-hash. The hash values returned by equal-hash, string-hash, and string-ci-hash are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.

procedure: ~(hashtable-set! hashtable key obj)~

returns: unspecified

libraries: (rnrs hashtables), (rnrs)


hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions. obj may be any Scheme object.

hashtable-set! associates key with obj in hashtable, replacing the existing association, if any.

(define ht (make-eq-hashtable))
(hashtable-set! ht 'a 73)

procedure: ~(hashtable-ref hashtable key default)~

returns: 参见下文

libraries: (rnrs hashtables), (rnrs)


key should be an appropriate key for the hashtable's hash and equivalence functions. default may be any Scheme object.

hashtable-ref returns the value associated with key in hashtable. If no value is associated with key in hashtable, hashtable-ref returns default.

(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))

(define eqht (make-eq-hashtable))
(hashtable-set! eqht p1 73)
(hashtable-ref eqht p1 55) => 73
(hashtable-ref eqht p2 55) => 55

(define equalht (make-hashtable equal-hash equal?))
(hashtable-set! equalht p1 73)
(hashtable-ref equalht p1 55) => 73
(hashtable-ref equalht p2 55) => 73

procedure: ~(hashtable-contains? hashtable key)~

returns: #t if an association for key exists in hashtable, #f otherwise

libraries: (rnrs hashtables), (rnrs)


key should be an appropriate key for the hashtable's hash and equivalence functions.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) => #t
(hashtable-contains? ht p2) => #f

procedure: ~(hashtable-update! hashtable key procedure default)~

returns: unspecified

libraries: (rnrs hashtables), (rnrs)


hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions. default may be any Scheme object. procedure should accept one argument, should return one value, and should not modify hashtable.

hashtable-update! applies procedure to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If procedure returns, hashtable-update! associates key with the value returned by procedure, replacing the old association, if any.

A version of hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows.

(define hashtable-update!
  (lambda (ht key proc value)
    (hashtable-set! ht key
      (proc (hashtable-ref ht key value)))))

An implementation may, however, be able to implement hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups.

(define ht (make-eq-hashtable))
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(hashtable-ref ht 'a 0) => 110
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(hashtable-ref ht 'a 0) => 220

procedure: ~(hashtable-delete! hashtable key)~

returns: unspecified

libraries: (rnrs hashtables), (rnrs)


hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions.

hashtable-delete! drops any association for key from hashtable.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) => #t
(hashtable-delete! ht p1)
(hashtable-contains? ht p1) => #f
(hashtable-contains? ht p2) => #f
(hashtable-delete! ht p2)

procedure: ~(hashtable-size hashtable)~

returns: number of entries in hashtable

libraries: (rnrs hashtables), (rnrs)


(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-size ht) => 0
(hashtable-set! ht p1 73)
(hashtable-size ht) => 1
(hashtable-delete! ht p1)
(hashtable-size ht) => 0

procedure: ~(hashtable-copy hashtable)~

procedure: ~(hashtable-copy hashtable mutable?)~

returns: a new hashtable containing the same entries as hashtable

libraries: (rnrs hashtables), (rnrs)


If mutable? is present and not false, the copy is mutable; otherwise, the copy is immutable.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(hashtable-set! ht p1 "c")
(define ht-copy (hashtable-copy ht))
(hashtable-mutable? ht-copy) => #f
(hashtable-delete! ht p1)
(hashtable-ref ht p1 #f) => #f
(hashtable-delete! ht-copy p1) => exception: not mutable
(hashtable-ref ht-copy p1 #f) => "c"

procedure: ~(hashtable-clear! hashtable)~

procedure: ~(hashtable-clear! hashtable size)~

returns: unspecified

libraries: (rnrs hashtables), (rnrs)


hashtable must be a mutable hashtable. If size is provided, it must be a nonnegative exact integer.

hashtable-clear! removes all entries from hashtable. If size is provided, the hashtable is reset to the given size, as if newly created by one of the hashtable creation operations with size argument size.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "first")
(hashtable-set! ht p2 "second")
(hashtable-size ht) => 2
(hashtable-clear! ht)
(hashtable-size ht) => 0
(hashtable-ref ht p1 #f) => #f

procedure: ~(hashtable-keys hashtable)~

returns: a vector containing the keys in hashtable

libraries: (rnrs hashtables), (rnrs)


The keys may appear in any order in the returned vector.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-keys ht) => #((a . b) q (a . b))

procedure: ~(hashtable-entries hashtable)~

returns: two vectors: one of keys and a second of values

libraries: (rnrs hashtables), (rnrs)


hashtable-entries returns two values. The first is a vector containing the keys in hashtable, and the second is a vector containing the corresponding values. The keys and values may appear in any order, but the order is the same for the keys and for the corresponding values.

(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-entries ht) => #((a . b) q (a . b))
                        #("two" "three" "one")

** Section 6.14. Enumerations

Enumerations are ordered sets of symbols, typically used to name and manipulate options, as with the buffer modes and file options that may be specified when files are created.

syntax: (define-enumeration name (symbol ...) constructor)

libraries: (rnrs enums), (rnrs)


A define-enumeration form is a definition and can appear anywhere any other definition can appear.

The define-enumeration syntax creates a new enumeration set with the specified symbols in the specified order forming the enumeration's universe. It defines a new syntactic form named by name that may be used to verify that a symbol is in the universe. If x is in the universe, (name x) evaluates to x. It is a syntax violation if x is not in the universe.

define-enumeration also defines a new syntactic form named by constructor that may be used to create subsets of the enumeration type. If x ... are each in the universe, (constructor x ...) evaluates to an enumeration set containing x .... Otherwise, it is a syntax violation. The same symbol may appear more than once in x ..., but the resulting set contains only one occurrence of the symbol.

(define-enumeration weather-element
  (hot warm cold sunny rainy snowy windy)
  weather)

(weather-element hot) => hot
(weather-element fun) => syntax violation
(weather hot sunny windy) => #<enum-set>
(enum-set->list (weather rainy cold rainy)) => (cold rainy)

procedure: ~(make-enumeration symbol-list)~

returns: an enumeration set

libraries: (rnrs enums), (rnrs)


This procedure creates a new enumeration type whose universe comprises the elements of symbol-list, which must be a list of symbols, in the order of their first appearance in the list. It returns the universe of the new enumeration type as an enumeration set.

(define positions (make-enumeration '(top bottom above top beside)))
(enum-set->list positions) => (top bottom above beside)

procedure: ~(enum-set-constructor enum-set)~

returns: an enumeration-set construction procedure

libraries: (rnrs enums), (rnrs)


This procedure returns a procedure p that may be used to create subsets of the universe of enum-set. p must be passed a list of symbols, and each element of the list must be an element of the universe of enum-set. The enumeration set returned by p contains all and only the symbols in the list it is passed. The value returned by p may contain elements not in enum-set if the universe of enum-set contains those elements.

(define e1 (make-enumeration '(one two three four)))
(define p1 (enum-set-constructor e1))
(define e2 (p1 '(one three)))
(enum-set->list e2) => (one three)
(define p2 (enum-set-constructor e2))
(define e3 (p2 '(one two four)))
(enum-set->list e3) => (one two four)

procedure: ~(enum-set-universe enum-set)~

returns: the universe of enum-set, as an enumeration set

libraries: (rnrs enums), (rnrs)


(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list (enum-set-universe e1)) => (a b c d)
(define e2 ((enum-set-constructor e1) '(c)))
(enum-set->list (enum-set-universe e2)) => (a b c d)

procedure: ~(enum-set->list enum-set)~

returns: a list of the elements of enum-set

libraries: (rnrs enums), (rnrs)


The symbols in the resulting list appear in the order given to them when the enumeration type of enum-set was created.

(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list e1) => (a b c d)
(define e2 ((enum-set-constructor e1) '(d c a b)))
(enum-set->list e2) => (a b c d)

procedure: ~(enum-set-subset? enum-set1 enum-set2)~

returns: #t if enum-set1 is a subset of enum-set2, #f otherwise

libraries: (rnrs enums), (rnrs)


An enumeration set enum-set1 is a subset of an enumeration set enum-set2 if and only if the universe of enum-set1 is a subset of the universe of enum-set2 and each element of enum-set1 is an element of enum-set2.

(define e1 (make-enumeration '(a b c)))
(define e2 (make-enumeration '(a b c d e)))
(enum-set-subset? e1 e2) => #t
(enum-set-subset? e2 e1) => #f
(define e3 ((enum-set-constructor e2) '(a c)))
(enum-set-subset? e3 e1) => #f
(enum-set-subset? e3 e2) => #t

procedure: ~(enum-set=? enum-set1 enum-set2)~

returns: #t if enum-set1 and enum-set2 are equivalent, #f otherwise

libraries: (rnrs enums), (rnrs)


Two enumeration sets enum-set1 and enum-set2 are equivalent if each is a subset of the other.

(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(b d c a)))
(enum-set=? e1 e2) => #t
(define e3 ((enum-set-constructor e1) '(a c)))
(define e4 ((enum-set-constructor e2) '(a c)))
(enum-set=? e3 e4) => #t
(enum-set=? e3 e2) => #f

enum-set=? could be defined in terms of enum-set-subset? as follows.

(define enum-set=?
  (lambda (e1 e2)
    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))

procedure: ~(enum-set-member? symbol enum-set)~

returns: #t if symbol is an element of enum-set, #f otherwise

libraries: (rnrs enums), (rnrs)


(define e1 (make-enumeration '(a b c d e)))
(define e2 ((enum-set-constructor e1) '(d b)))
(enum-set-member? 'c e1) => #t
(enum-set-member? 'c e2) => #f

procedure: ~(enum-set-union enum-set1 enum-set2)~

returns: the union of enum-set1 and enum-set2

procedure: ~(enum-set-intersection enum-set1 enum-set2)~

returns: the intersection of enum-set1 and enum-set2

procedure: ~(enum-set-difference enum-set1 enum-set2)~

returns: the difference of enum-set1 and enum-set2

libraries: (rnrs enums), (rnrs)


enum-set1 and enum-set2 must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets.

(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a c)))
(define e3 ((enum-set-constructor e1) '(b c)))
(enum-set->list (enum-set-union e2 e3)) => (a b c)
(enum-set->list (enum-set-intersection e2 e3)) => (c)
(enum-set->list (enum-set-difference e2 e3)) => (a)
(enum-set->list (enum-set-difference e3 e2)) => (b)
(define e4 (make-enumeration '(b d c a)))
(enum-set-union e1 e4) => exception: different enumeration types

procedure: ~(enum-set-complement enum-set)~

returns: the complement of enum-set relative to its universe

libraries: (rnrs enums), (rnrs)


(define e1 (make-enumeration '(a b c d)))
(enum-set->list (enum-set-complement e1)) => ()
(define e2 ((enum-set-constructor e1) '(a c)))
(enum-set->list (enum-set-complement e2)) => (b d)

procedure: ~(enum-set-projection enum-set1 enum-set2)~

returns: the projection of enum-set1 into the universe of enum-set2

libraries: (rnrs enums), (rnrs)


Any elements of enum-set1 not in the universe of enum-set2 are dropped. The result is of the same enumeration type as enum-set2.

(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(a b c d e f g)))
(define e3 ((enum-set-constructor e1) '(a d)))
(define e4 ((enum-set-constructor e2) '(a c e g)))
(enum-set->list (enum-set-projection e4 e3)) => (a c)
(enum-set->list
  (enum-set-union e3
    (enum-set-projection e4 e3))) => (a c d)

procedure: ~(enum-set-indexer enum-set)~

returns: a procedure that returns the index of a symbol in the universe of enum-set

libraries: (rnrs enums), (rnrs)


enum-set-indexer returns a procedure p that, when applied to a symbol in the universe of enum-set, returns the index of the symbol (zero-based) in the ordered set of symbols that form the universe. If applied to a symbol not in the universe, p returns #f.

(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a d)))
(define p (enum-set-indexer e2))
(list (p 'a) (p 'c) (p 'e)) => (0 2 #f)

R. Kent Dybvig / The Scheme Programming Language, Fourth Edition
Copyright © 2009 The MIT Press. Electronically reproduced by permission.
Illustrations © 2009 Jean-Pierre Hébert
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
to order this book / about this book

http://www.scheme.com
