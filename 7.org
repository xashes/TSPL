#+OPTIONS: toc:nil
* Chapter 7. Input and Output

所有输入和输出操作都是通过端口进行的。端口是一个指向数据（常常是文件）流（可能无穷）的指针，通过这个通道，程序可以从流中读取字节或字符，或往流中写入字节或字符。端口可以是输入端口，输出端口或同为两者。

端口是第一类对象，在 Scheme 中和任何其它对象一样。如同过程，端口也没有像字符串和数字那样的打印形式。初始的端口有三种：当前输入端口，当前输出端口，及当前错误端口，它们是连接到进程的标准输入，标准输出，和标准错误流的文本端口。Scheme 也提供了多种方法去开启新的端口。

一个输入端口通常指向一个有限的流，例如，储存在硬盘上的一个输入文件。如果一个输入操作，例如，get-u8, get-char, or get-datum, 请求读取的部分到达了有限流的末尾，则它返回一个特殊的 eof（文件结尾）对象。谓词 eof-object? 可以用于判定输入操作返回的值是否是 eof 对象。

端口或是二进制，或是文本的。二进制端口支持程序从其所代表的流中，读取或写入 8 位无符号字节，或称 "octets"。文本端口支持程序读取或写入字符。

很多情况下，底层的流被组织为一个字节序列，但这些字节应当被作为字符编码处理。在这种情况下，可以通过编码转换器创建一个文本端口，把字节解码为字符（对于输入端口），或把字符编码为字节（对于输出端口）。编码转换器封装了一个编码解码器，它决定了字符如何表示为字节。Scheme 提供了三种标准编码解码器：latin-1 编码解码器，Unicode utf-8 编码解码器，以及 Unicode utf-16 编码解码器。在 latin-1 编码中，每个字符以正好一个字节表示。在 utf-8 编码中，每个字符以一至四个字节表示，而在 utf-16 编码中，每个字符以二或四个字节表示。

编码转换器同时封装了 eol 风格，它决定了是否以及如何识别行尾。如果 eol 风格为 none，则不识别行尾。另外六种标准 eol 风格如下所示：

#+begin_quote
lf: 	line-feed character（换行字符）
cr: 	carriage-return character（回车字符）
nel: 	Unicode next-line character（Unicode 新行字符）
ls: 	Unicode line-separator character（Unicode 行分隔字符）
crlf: 	carriage return followed by line feed（回车加换行字符）
crnel: 	carriage return followed by next line（回车加新行字符）
#+end_quote

eol 风格对输入和输出操作的影响是不同的。对于输入，除了 none 以外的任何 eol 风格，会把每种行尾字符或双字符序列转换为一个单个的换行字符。对于输出，除了 none 以外的任何 eol 风格，会把换行字符转换为与 eol 风格相关联的特定单个字符或双字符序列。在输入方向上，除了 none 以外的所有 eol 风格都是等价的，而在输出方向上，eol 风格 none 和 lf 是等价的。

除了编码解码器和 eol 风格，编码转换器只封装了另外一种信息：一个错误处理模式，它决定了在解码或编码错误出现时会发生什么，即，如果通过封装的编码解码器，在输入方向上，无法把一个字节序列转换成一个字符，或在输出方向上，无法把一个字符转换成一个字节序列。错误处理模式为 ignore, raise, 或 replace. 如果错误处理模式为 ignore, 则忽略出错的字节序列或字符。如果错误处理模式为 raise, 则抛出条件类型的 i/o-decoding 或 i/o-encoding 异常；在输入方向上，端口的位置在字节序列前面。如果错误处理模式为 replace, 会生成一个替换字符或字符编码：在输入方向上，替换字符是 U+FFFD, 而在输出方向上，则替换编码为 utf-8 和 utf-16 编码解码器的 U+FFFD 的编码，或是 latin-1 编码解码器的问号字符（?）的编码。

为了提高效率，可以缓冲端口，以减少为每个字节或字符进行系统调用的开销。Scheme 支持三种标准缓冲模式：block, line, 和 none. 在 block 缓冲模式中，是以块的形式从流中读取输入或向流发送输出，块的大小与实现相关。在 line 缓冲模式中，缓冲以行为基础，或以其它某些实现相关的基础进行。Line 缓冲通常只在文本输出端口中与 block 缓冲有区别；在二进制端口中没有行划分，而输入常常是在它可用时即从流中读取。在 none 缓冲模式中，不进行缓冲，所以输出会立即发送到流，而输入则只在需要时读取。

本章的其余部分包含了编码转换器操作，文件端口，标准端口，输出操作，快捷 I/O, 文件系统操作，字节向量和字符串之间的转换。

** Section 7.1. Transcoders

如上所述，编码转换器封装了三个值：编码解码器，eol 风格，和错误处理模式。本节介绍了创建和操作编码转换器的过程，以及编码转换器封装的值。

procedure: ~(make-transcoder codec)~
procedure: ~(make-transcoder codec eol-style)~
procedure: ~(make-transcoder codec eol-style error-handling-mode)~
returns: 封装了编码解码器，eol 风格，和错误处理模式的编码转换器
libraries: (rnrs io ports), (rnrs)

eol-style 必须是一个有效的 eol 风格符号 (lf, cr, nel, ls, crlf, crnel, 或 none); 它默认为平台的原生 eol 风格。error-handling-mode 必须是一个有效的错误处理模式符号 (ignore, raise, 或 replace)，默认值为 replace.

procedure: ~(transcoder-codec transcoder)~
returns: transcoder 封装的编码解码器
procedure: ~(transcoder-eol-style transcoder)~
returns: transcoder 封装的 eol 风格符号
procedure: ~(transcoder-error-handling-mode transcoder)~
returns: transcoder 封装的错误处理模式符号
libraries: (rnrs io ports), (rnrs)

procedure: ~(native-transcoder)~
returns: 原生的编码转换器
libraries: (rnrs io ports), (rnrs)

原生的编码转换器是依赖于实现的，且可能根据平台或区域设置有所变化。

procedure: ~(latin-1-codec)~
returns: ISO 8859-1 (Latin 1) 字符编码的编码解码器
procedure: ~(utf-8-codec)~
returns: Unicode UTF-8 字符编码的编码解码器
procedure: ~(utf-16-codec)~
returns: Unicode UTF-16 字符编码的编码解码器
libraries: (rnrs io ports), (rnrs)

syntax: ~(eol-style symbol)~
returns: symbol
libraries: (rnrs io ports), (rnrs)

symbol 必须是以下符号之一：lf, cr, nel, ls, crlf, crnel, 或 none. 表达式 (eol-style symbol) 等价于表达式 (quote symbol), 除了前者在展开期会检查 symbol 是否是 eol 风格符号之一。eol-style 语法也提供了有用的文档。
except the former checks at expansion time that symbol is one of the eol-style symbols. The eol-style syntax provides useful documentation as well.

#+begin_src scheme
(eol-style crlf) => crlf
(eol-style lfcr) => syntax violation
#+end_src

procedure: ~(native-eol-style)~
returns: 原生的 eol 风格
libraries: (rnrs io ports), (rnrs)

原生的 eol 风格是依赖于实现的，且可能根据平台或区域设置有所变化。

syntax: ~(error-handling-mode symbol)~
returns: symbol
libraries: (rnrs io ports), (rnrs)

symbol 必须是以下符号之一：ignore, raise, 或 replace. 表达式 (error-handling-mode symbol) 等价于表达式 (quote symbol), 除了前者在展开期会检查 symbol 是否是错误处理模式符号之一。error-handling-mode 语法也提供了有用的文档。

#+begin_src scheme
  (error-handling-mode replace) => replace
  (error-handling-mode relpace) => syntax violation
#+end_src

** Section 7.2. Opening Files

本节中的过程用于打开文件端口。用于打开其它类型端口的过程，例如，字符串端口，或自定义端口，将在后面的章节中介绍。

Each of the file-open operations accepts a path argument that names the file to be opened. It must be a string or some other implementation-dependent value that names a file.
每个文件打开操作接受一个路径实参，命名了要打开的文件。它必须是命名了一个文件的字符串或其它某些平台相关的值。

某些文件打开操作接受可选的 options, b-mode, 和 ?transcoder 实参。options 必须是一个枚举集合，由下文 file-options 条目中介绍的有效文件选项符号组成，默认值为 (file-options) 的值。b-mode 必须是下文 buffer-mode 条目中介绍的有效缓冲模式，默认值为 block. ?transcoder 必须是一个编码转换器，或 #f; 如果它是一个编码转换器，则打开操作返回底层二进制文件的编码转换后的端口，如果它是 #f（默认值），则打开操作返回一个二进制端口。

由本节中的过程创建的二进制端口，支持 port-position 和 set-port-position! 操作。而由本节中的过程创建的文本端口，是否支持这些操作则依赖于实现。

syntax: ~(file-options symbol ...)~
returns: 一个文件选项的枚举集合
libraries: (rnrs io ports), (rnrs)

File-options enumeration sets may be passed to file-open operations to control aspects of the open operation. There are three standard file options: no-create, no-fail, and no-truncate, which affect only file-open operations that create output (including input/output) ports.
文件选项枚举集合可以传入文件打开操作，以从多方面控制打开操作。有三种标准文件选项：no-create, no-fail, 以及 no-truncate, 这些选项只影响创建输出（包括输入/输出）端口的文件打开操作。

With the default file options, i.e., the value of (file-options), when a program attempts to open a file for output, an exception is raised with condition type i/o-file-already-exists if the file already exists, and the file is created if it does not already exist. If the no-fail option is included, no exception is raised if the file already exists; instead, the file is opened and truncated to zero length. If the no-create option is included, the file is not created if it does not exist; instead, an exception is raised with condition type i/o-file-does-not-exist. The no-create option implies the no-fail option. The no-truncate option is relevant only if the no-fail option is included or implied, in which case if an existing file is opened, it is not truncated, but the port's position is still set to the beginning of the file.
文件选项为默认值时，即 (file-option) 的值，当程序尝试打开一个文件作为输出时，如果此文件已经存在，则会抛出一个条件类型的 i/o-file-already-exists 异常，如果文件不存在，则会创建此文件。如果包含 no-fail 选项，则在文件已经存在时不会抛出异常；而是打开此文件，并把它的长度截短为 0. 如果包含 no-create 选项，则文件不存在时不会创建此文件；而是抛出一个条件类型的 i/o-file-dose-not-exist 异常。no-create 选项暗含了 no-fail 选项。只在包含或暗含 no-fail 选项时，no-truncate 选项才有意义，此时如果打开一个已经存在的文件，它不会被截短，但是，端口的位置仍然被设定于文件的起始处。

It is perhaps easier to imagine that the default file options are the imaginary option symbols create, fail-if-exists, and truncate; no-create removes create, no-fail removes fail-if-exists, and no-truncate removes truncate.
可能不难想象，默认的文件选项是虚构的选项符号 create, fail-if-exists, 和 truncate; no-create 移除了 create, no-fail 移除了 fail-if-exists, 而 no-truncate 移除了 truncate.

Implementations may support additional file option symbols. Chez Scheme, for example, supports options that control whether the file is or should be compressed, whether it is locked for exclusive access, and what permissions are given to the file if it is created [9].
具体实现可能支持额外的文件选项符号。例如，Chez Scheme 支持选项控制文件是否应被压缩，是否为独有的访问锁定，以及当文件创建时被给予什么权限。

syntax: ~(buffer-mode symbol)~
returns: symbol
libraries: (rnrs io ports), (rnrs)

symbol must be one of the symbols block, line, or none. The expression (buffer-mode symbol) 等价于 the expression (quote symbol) except that the former checks at expansion time that symbol is one of the buffer-mode symbols. The buffer-mode syntax provides useful documentation as well.
symbol 必须是以下符号之一：block, line, 或 none. 表达式 (buffer-mode symbol) 等价于表达式 (quote symbol), 除了前者在展开期会检查 symbol 是否是缓冲模式符号之一。buffer-mode 语法也提供了有用的文档。

#+begin_src scheme
(buffer-mode block) => block
(buffer-mode cushion) => syntax violation
#+end_src

syntax: ~(buffer-mode? obj)~
返回: 如果 ~obj~ 是一个有效的缓冲模式，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs)

#+begin_src scheme
(buffer-mode? 'block) => #t
(buffer-mode? 'line) => #t
(buffer-mode? 'none) => #t
(buffer-mode? 'something-else) => #f
#+end_src

procedure: ~(open-file-input-port path)~
procedure: ~(open-file-input-port path options)~
procedure: ~(open-file-input-port path options b-mode)~
procedure: ~(open-file-input-port path options b-mode ?transcoder)~
returns: 指定文件的一个新的输入端口
libraries: (rnrs io ports), (rnrs)

If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
如果指定了 ?transcoder, 且不为 #f, 则它必须是一个编码转换器，而这个过程返回一个文本输入端口，它的编码转换器为 ?transcoder. 否则，这个过程返回一个二进制输入端口。关于其它实参的约束条件和影响，请参见本节引言中的介绍。

procedure: ~(open-file-output-port path)~
procedure: ~(open-file-output-port path options)~
procedure: ~(open-file-output-port path options b-mode)~
procedure: ~(open-file-output-port path options b-mode ?transcoder)~
returns: a new output port for the named file
libraries: (rnrs io ports), (rnrs)

If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
如果指定了 ?transcoder, 且不为 #f, 则它必须是一个编码转换器，而这个过程返回一个文本输出端口，它的编码转换器为 ?transcoder. 否则，这个过程返回一个二进制输出端口。关于其它实参的约束条件和影响，请参见本节引言中的介绍。

procedure: ~(open-file-input/output-port path)~
procedure: ~(open-file-input/output-port path options)~
procedure: ~(open-file-input/output-port path options b-mode)~
procedure: ~(open-file-input/output-port path options b-mode ?transcoder)~
returns: a new input/output port for the named file
libraries: (rnrs io ports), (rnrs)

If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
如果指定了 ?transcoder, 且不为 #f, 则它必须是一个编码转换器，而这个过程返回一个文本输入/输出端口，它的编码转换器为 ?transcoder. 否则，这个过程返回一个二进制输入/输出端口。关于其它实参的约束条件和影响，请参见本节引言中的介绍。

** Section 7.3. Standard Ports

The procedures described in this section return ports that are attached to a process's standard input, standard output, and standard error streams. The first set returns "ready-made" textual ports with implementation-dependent transcoders (if any) and buffer modes. The second set creates fresh binary ports and can be used either for binary input/output or, with the help of transcoded-port, for textual input/output with program-supplied transcoders and buffer modes.
本节介绍的过程返回附着于一个进程的标准输入，标准输出，和标准错误流上的端口。第一个过程集返回 "ready mode" 文本端口，带有依赖于实现的编码转换器（如果存在的话）和缓冲模式。第二个过程集创建新的二进制端口，可用于二进制输入/输出，或在 transcoded-port 的帮助下，用于带有程序提供的编码转换器和缓冲模式的文本输入/输出。

procedure: ~(current-input-port)~
returns: 当前输入端口
procedure: ~(current-output-port)~
returns: 当前输出端口
procedure: ~(current-error-port)~
returns: 当前错误端口
libraries: (rnrs io ports), (rnrs io simple), (rnrs)

The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process's standard input, standard output, and standard error streams.
当前输入，当前输出，和当前错误端口返回预设的文本端口，初始关联于进程的标准输入，标准输出，和标准错误流。

The values returned by current-input-port and current-output-port can be altered temporarily by the convenience I/O procedures with-input-from-file and with-output-to-file (Section 7.9).
可以通过便捷的 I/O 过程 with-input-from-file 和 with-output-to-file（7.9 节）临时替代 current-input-port 和 current-output-port 返回的值。

procedure: ~(standard-input-port)~
returns: 连接到标准输入流的一个全新的二进制输入端口
procedure: ~(standard-output-port)~
returns: 连接到标准输出流的一个全新的二进制输出端口
procedure: ~(standard-error-port)~
returns: 连接到标准错误流的一个全新的二进制输出端口
libraries: (rnrs io ports), (rnrs)

Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process's standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams.
由于端口可以缓存，如果在进程的一个标准流连接的多个端口上交叉操作，就可能会导致混淆。因此，这些过程通常只适用于程序不再需要使用标准流上连接的任何已有端口时。

** Section 7.4. String and Bytevector Ports

本节的过程支持把字节向量和字符串用作输入和输出流。

本节中的过程创建的二进制端口，支持 port-position 和 set-port-position! 操作。本节中的过程创建的文本端口是否支持这些操作，则是依赖于具体实现的。

procedure: ~(open-bytevector-input-port bytevector)~
procedure: ~(open-bytevector-input-port bytevector ?transcoder)~
returns: 从 bytevector 获取输入的一个新的输入端口
libraries: (rnrs io ports), (rnrs)

如果传入 ?transcoder, 且其值不是 #f, 则它必须是一个编码转换器， 而这个过程返回一个文本输入端口，端口的编码转换器为 ?transcoder. 否则，这个过程返回一个二进制输入端口。
。is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port.

The effect of modifying bytevector after this procedure is called is unspecified.
在调用这个过程之后修改 bytevector 的效果是未定义的。

#+begin_src scheme
(let ([ip (open-bytevector-input-port #vu8(1 2))])
  (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])
    (list x1 x2 (eof-object? x3)))) => (1 2 #t)
#+end_src

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
没有必要关闭一个字节向量端口；当不再需要时，它的存储会被自动回收，和对任何其它对象一样。而且，一个打开的字节向量端口不会绑定任何操作系统资源。

procedure: ~(open-string-input-port string)~
returns: 从 string 获取输入的一个新的文本输入端口
libraries: (rnrs io ports), (rnrs)

The effect of modifying string after this procedure is called is unspecified. The new port may or may not have a transcoder, and if it does, the transcoder is implementation-dependent. While not required, implementations are encouraged to support port-position and set-port-position! for string ports.
在调用这个过程之后修改 string 的效果是未定义的。新端口可能有也可能没有编码转换器，而如果它有的话，此编码转换器是与实现相关的。虽然不是强制要求，但实现最好支持字符串端口的 port-position 和 set-port-position! 操作。

#+begin_src scheme
(get-line (open-string-input-port "hi.\nwhat's up?\n")) => "hi."
#+end_src

There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.
没有必要关闭一个字符串端口；当不再需要时，它的存储会被自动回收，和对任何其它对象一样。而且，一个打开的字符串端口不会绑定任何操作系统资源。

procedure: ~(open-bytevector-output-port)~
procedure: ~(open-bytevector-output-port ?transcoder)~
returns: 两个值——一个新的输出端口和一个提取过程
libraries: (rnrs io ports), (rnrs)

If ?transcoder is present and not #f, it must be a transcoder, and the port value is a textual output port whose transcoder is ?transcoder. Otherwise, the port value is a binary output port.
如果传入 ?transcoder, 且其值不是 #f, 则它必须是一个编码转换器，且端口值是一个文本输出端口，其编码转换器为 ?transcoder. 否则，端口值为一个二进制输出端口。

The extraction procedure is a procedure that, when called without arguments, creates a bytevector containing the accumulated bytes in the port, clears the port of its accumulated bytes, resets its position to zero, and returns the bytevector. The accumulated bytes include any bytes written beyond the end of the current position, if the position has been set back from its maximum extent.
提取过程是一个过程，当不带实参调用时，创建一个字节向量，其中包含端口中累积的字节，然后把端口累积的字节清空，把它的位置重置为 0, 并返回它创建的字节向量。如果当前位置被设回它的最大范围以内，累积的字节也包括当前位置后面写入的所有字节。

#+begin_src scheme
(let-values ([(op g) (open-bytevector-output-port)])
  (put-u8 op 15)
  (put-u8 op 73)
  (put-u8 op 115)
  (set-port-position! op 2)
  (let ([bv1 (g)])
    (put-u8 op 27)
    (list bv1 (g)))) => (#vu8(15 73 115) #vu8(27))
#+end_src

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
没有必要关闭一个字节向量端口；当不再需要时，它的存储会被自动回收，和对任何其它对象一样。而且，一个打开的字节向量端口不会绑定任何操作系统资源。

procedure: ~(open-string-output-port)~
returns: two values, a new textual output port and an extraction procedure
returns: 两个值——一个新的文本输出端口和一个提取过程
libraries: (rnrs io ports), (rnrs)

The extraction procedure is a procedure that, when called without arguments, creates a string containing the accumulated characters in the port, clears the port of its accumulated characters, resets its position to zero, and returns the string. The accumulated characters include any characters written beyond the end of the current position, if the position has been set back from its maximum extent. While not required, implementations are encouraged to support port-position and set-port-position! for string ports.
提取过程是一个过程，当不带实参调用时，创建一个字符串，其中包含端口中累积的字符，然后把端口累积的字符清空，把它的位置重置为 0, 并返回它创建的字符串。如果当前位置被设回它的最大范围以内，累积的字符也包括当前位置后面写入的所有字符。虽然不是强制要求，但实现最好支持字符串端口的 port-position 和 set-port-position! 操作。

#+begin_src scheme
(let-values ([(op g) (open-string-output-port)])
  (put-string op "some data")
  (let ([str1 (g)])
    (put-string op "new stuff")
    (list str1 (g)))) => ("some data" "new stuff")
#+end_src

There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.
没有必要关闭一个字符串端口；当不再需要时，它的存储会被自动回收，和对任何其它对象一样。而且，一个打开的字符串端口不会绑定任何操作系统资源。

procedure: ~(call-with-bytevector-output-port procedure)~
procedure: ~(call-with-bytevector-output-port procedure ?transcoder)~
returns: 一个字节向量，包含累积的字节
libraries: (rnrs io ports), (rnrs)

If ?transcoder is present and not #f, it must be a transcoder, and procedure is called with a textual bytevector output port whose transcoder is ?transcoder. Otherwise, procedure is called with a binary bytevector output port. 
If procedure returns, a bytevector containing the bytes accumulated in the port is created, the accumulated bytes are cleared from the port, the port's position is reset to zero, and the bytevector is returned from call-with-bytevector-output-port. These actions occur each time procedure returns, if it returns multiple times due to the invocation of a continuation created while procedure is active.
如果传入 ?transcoder, 且其值不为 #f, 则它必须是一个编码转换器，而 procedure 以一个文本字节向量输出端口调用，它的编码转换器为 ?transcoder. 否则，procedure 以一个二进制字节向量输出端口调用。当 procedure 返回，会创建一个包含端口中累积字节的字节向量，从端口中清除累积的字节，把端口的位置重置为 0, 并从 call-with-bytevector-output-port 中返回字节向量。TODO
在每次 procedure 返回时，这些动作发生一遍。

#+begin_src scheme
(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)
            (error-handling-mode replace))])
  (call-with-bytevector-output-port
    (lambda (p) (put-string p "abc"))
    tx)) => #vu8(97 98 99)
#+end_src

procedure: ~(call-with-string-output-port procedure)~
returns: a string containing the accumulated characters
libraries: (rnrs io ports), (rnrs)

procedure is called with one argument, a string output port. If procedure returns, a string containing the characters accumulated in the port is created, the accumulated characters are cleared from the port, the port's position is reset to zero, and the string is returned from call-with-string-output-port. These actions occur each time procedure returns, if it returns multiple times due to the invocation of a continuation created while procedure is active.

call-with-string-output-port can be used along with put-datum to define a procedure, object->string, that returns a string containing the printed representation of an object.

#+begin_src scheme
(define (object->string x)
  (call-with-string-output-port
    (lambda (p) (put-datum p x))))
#+end_src

#+begin_src scheme
(object->string (cons 'a '(b c))) => "(a b c)"
#+end_src

** Section 7.5. 开启自定义端口 Opening Custom Ports

procedure: ~(make-custom-binary-input-port id r! gp sp! close)~
returns: 一个新的自定义二进制输入端口
procedure: ~(make-custom-binary-output-port id w! gp sp! close)~
returns: 一个新的自定义二进制输出端口
procedure: ~(make-custom-binary-input/output-port id r! w! gp sp! close)~
returns: 一个新的自定义二进制输入/输出端口
libraries: (rnrs io ports), (rnrs)

These procedures allow programs to create ports from arbitrary byte streams. id must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. r! and w! must be procedures, while gp, sp!, and close must each be a procedure or #f. These arguments are described below.
这些过程允许程序通过任意字节流创建端口。id 必须是一个命名新端口的字符串；名字只是用于信息用途，而一个实现可以选择把它包含在自定义端口的打印语法形式（如果存在的话）中。r! 和 w! 必须是过程，而 gp, sp! 和 close 均必须为过程或 #f. 这些实参介绍如下。

~r!~
    为了从自定义端口获取输入而调用，例如，为了支持 get-u8 或 get-bytevector-n. 调用时传入三个实参：bytevector, start, 和 n. start 会是一个非负精确整数，n 会是一个正的精确整数，而 start 和 n 的和不能超过 bytevector 的长度。如果字节流在文件的结尾，r! 应该返回精确的 0. 否则，它应该从流中读入最小 1 个，最多 n 个字节，把这些字节存储在 bytevector 起始于 start 的连续位置上，并把实际读入的字节数作为一个精确的正整数返回。

~w!~
    为了向端口发送输出而调用，例如，为了支持 put-u8 或 put-bytevector. 调用时传入三个实参：bytevector, start, 和 n. start 和 n 会是非负精确整数，而 start 和 n 的和不能超过 bytevector 的长度。w!应当写入 bytevector 中始于 start 的至多 n 个连续字节，并把实际写入的字节数作为一个精确的非负整数返回。
It is called with three arguments: bytevector, start, and n. start and n will be nonnegative exact integers, and the sum of start and n will not exceed the length of bytevector. w! should write up to n consecutive bytes from bytevector starting at start and return, as an exact nonnegative integer, the number of bytes actually written.

~gp~
    is called to query the port's position. If it is #f, the port will not support port-position. If it is not #f, it will be passed zero arguments and should return the current position as a displacement in bytes from the start of the byte stream as an exact nonnegative integer.
    为了查询端口位置而调用。如是它为 #f, 则端口不会支持 port-position. 如果它不为 #f, 它会被传入 0 个实参，并把字节流从开始位置起的字节偏移量作为当前位置，返回为一个精确的非负整数。

~sp!~
    为了设置端口位置而调用。如果它为 #f, 则端口不会支持 set-port-position!. 如果它不为 #f, 它会被传入 1 个实参——一个精确的非负整数，以字节流从开始位置起的字节偏移量表示的新位置，而它应当把位置设为这个值。
    If it is not #f, it will be passed one argument, an exact nonnegative integer representing the new position as a displacement in bytes from the start of the byte stream, and it should set the position to this value.

~close~
    为了关闭字节流而调用。如果它为 #f, 当新端口关闭时，不会采取任何动作以关闭字节流。如果它不为 #f, 它会被传入 0 个实参， 并会采取一切必要的动作以关闭字节流。
is called to close the byte stream. If it is #f, no action will be taken to close the byte stream when the new port is closed. If it is not #f, it will be passed zero arguments and should take whatever actions are necessary to close the byte stream. 

If the new port is an input/output port and does not provide either a gp or sp! procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support lookahead-u8 and is often done anyway for efficiency. For the same reason, a call to port-position after an input operation may not return an accurate position if the sp! procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both gp and sp! procedures.
如果新端口是一个输入/输出端口，而且未提供 gp 或 sp! 过程，则当一个输出操作发生在一个输入操作之后时，实现很可能无法正确定位端口，因为，为了支持 lookahead-u8 而必须完成的输入缓冲，为了效率经常会无条件完成。基于同样的原因，在一个输入操作之后调用 port-position，如果没有提供 sp!过程，则可能无法返回一个精确的位置。因此，创建自定义二进制输入/输出端口的程序，通常应当提供 gp 和 sp! 过程。

procedure: ~(make-custom-textual-input-port id r! gp sp! close)~
returns: 一个新的自定义文本输入端口
procedure: ~(make-custom-textual-output-port id w! gp sp! close)~
returns: 一个新的自定义文本输出端口
procedure: ~(make-custom-textual-input/output-port id r! w! gp sp! close)~
returns: 一个新的自定义文本输入/输出端口
libraries: (rnrs io ports), (rnrs)

These procedures allow programs to create ports from arbitrary character streams. id must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. r! and w! must be procedures, while gp, sp!, and close must each be a procedure or #f. These arguments are described below.
这些过程允许程序通过任意字符流创建端口。id 必须是一个命名新端口的字符串；名字只是用于信息用途，而一个实现可以选择把它包含在自定义端口的打印语法形式（如果存在的话）中。r! 和 w! 必须是过程，而 gp, sp! 和 close 均必须为过程或 #f. 这些实参介绍如下。

r!
    is called to draw input from the port, e.g., to support get-char or get-string-n. It is called with three arguments: string, start, and n. start will be a nonnegative exact integer, n will be a positive exact integer, and the sum of start and n will not exceed the length of string. If the character stream is at end of file, r! should return exact 0. Otherwise, it should read at least one and at most n characters from the stream, store these characters in consecutive locations of string starting at start, and return as an exact positive integer the number of characters actually read.
    为了从端口获取输入而调用，例如，为了支持 get-char 或 get-string-n. 调用时传入三个实参：string, start, 和 n. start 会是一个非负精确整数，n 会是一个正的精确整数，而 start 和 n 的和不能超过 string 的长度。如果字符流在文件的结尾，r! 应该返回精确的 0. 否则，它应该从流中读入最小 1 个，最多 n 个字符，把这些字符存储在 string 起始于 start 的连续位置上，并把实际读入的字符数作为一个精确的正整数返回。

w!
    is called to send output to the port, e.g., to support put-char or put-string. It is called with three arguments: string, start, and n. start and n will be nonnegative exact integers, and the sum of start and n will not exceed the length of string. w! should write up to n consecutive characters from string starting at start and return, as an exact nonnegative integer, the number of characters actually written.
    为了向端口发送输出而调用，例如，为了支持 put-char 或 put-string. 调用时传入三个实参：string, start, 和 n. start 和 n 会是非负精确整数，而 start 和 n 的和不能超过 string 的长度。w!应当写入 string 中始于 start 的至多 n 个连续字符，并把实际写入的字符数作为一个精确的非负整数返回。

gp
    is called to query the port's position. If it is #f, the port will not support port-position. If it is not #f, it will be passed zero arguments and should return the current position, which may be an arbitrary value.
    为了查询端口位置而调用。如是它为 #f, 则端口不会支持 port-position. 如果它不为 #f, 它会被传入 0 个实参，并返回当前位置，其可能为任意值。

~sp!~
    is called to set the port's position. If it is #f, the port will not support set-port-position!. If it is not #f, it will be passed one argument, pos, a value representing the new position. If pos is the result of a previous call to gp, sp! should set the position to pos.
    为了设置端口位置而调用。如果它为 #f, 则端口不会支持 set-port-position!. 如果它不为 #f, 它会被传入 1 个实参——pos, 一个表示新位置的值。如果 pos 是之前对 gp 的一个调用的结果，则 sp! 应当把位置设为 pos.

close
    is called to close the character stream. If it is #f, no action will be taken to close the character stream when the new port is closed. If it is not #f, it will be passed zero arguments and should take whatever actions are necessary to close the character stream. 
~close~
    为了关闭字符流而调用。如果它为 #f, 当新端口关闭时，不会采取任何动作以关闭字符流。如果它不为 #f, 它会被传入 0 个实参， 并会采取一切必要的动作以关闭字符流。

If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the gp and sp! procedures are provided, due to input buffering that must be done to support lookahead-char and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the gp return value to account for the number of buffered characters. For the same reason, a call to port-position after an input operation may not return an accurate position, even if the sp! procedure is provided.
如果新端口是一个输入/输出端口，则当一个输出操作发生在一个输入操作之后时，即使提供了 gp 或 sp! 过程，实现也很可能无法正确定位端口，因为，为了支持 lookahead-char 而必须完成的输入缓冲，为了效率经常会无条件完成。由于没有指定端口位置的表示形式，实现无法调整 gp 的返回值，以计入缓冲的字符数。基于同样的原因，在一个输入操作之后调用 port-position，即使提供了 sp!过程，也可能无法返回一个精确的位置。

It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both gp and sp! procedures, and consumers of these ports should obtain the starting position via port-position before any input operations and reset the position back to the starting position before doing any output operations.
然而，如果位置被重置为起始位置，则应该能够在读取后可靠地执行输出。因此，创建自定义文本输入/输出端口的程序，通常应当提供 gp 和 sp! 过程，而这些端口的使用者应当在任何输入操作之前，通过 port-position 获取起始位置，并在进行任何输出操作之前，把位置重置回起始位置。


** Section 7.6. Port Operations

This section describes a variety of operations on ports that do not directly involve either reading from or writing to a port. The input and output operations are described in subsequent sections.
本节介绍了多种不直接涉及读写端口的端口操作。输入和输出操作会在后续章节中介绍。

procedure: ~(port? obj)~
返回: 如果 ~obj~ 是端口，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs)

procedure: ~(input-port? obj)~
返回: 如果 ~obj~ 是输入端口或输入/输出端口，则为 ~#t~, 否则为 ~#f~.
procedure: ~(output-port? obj)~
返回: 如果 ~obj~ 是输出端口或输入/输出端口，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs io simple), (rnrs)

procedure: ~(binary-port? obj)~
返回: 如果 ~obj~ 是二进制端口，则为 ~#t~, 否则为 ~#f~.
procedure: ~(textual-port? obj)~
返回: 如果 ~obj~ 是文本端口，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs)

procedure: ~(close-port port)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

If port is not already closed, close-port closes it, first flushing any buffered bytes or characters to the underlying stream if the port is an output port. Once a port has been closed, no more input or output operations may be performed on the port. Because the operating system may place limits on the number of file ports open at one time or restrict access to an open file, it is good practice to close any file port that will no longer be used for input or output. If the port is an output port, closing the port explicitly also ensures that buffered data is written to the underlying stream. Some Scheme implementations close file ports automatically after they become inaccessible to the program or when the Scheme program exits, but it is best to close file ports explicitly whenever possible. Closing a port that has already been closed has no effect.
如果端口尚未关闭，则 close-port 会关闭它，如果端口是输出端口，首先要把任何缓存的字节或字符 flush 进底层的流。一旦端口被关闭，就不可以在端口上再进行任何的输入或输出操作。由于操作系统可能会对同时开启的文件端口数量设限，或对打开文件的访问设限，因此，关闭任何不再用于输入或输出的文件端口是个好的习惯。如果端口是输出端口，显式关闭端口同样确保了缓冲数据会被写入底层的流。某些 Scheme 实现，在文件端口对程序变得不可访问，或在 Scheme 程序退出后，会自动关闭文件端口，但最好还是尽可能显式关闭文件端口。关闭一个已经关闭的端口不会产生任何影响。

procedure: ~(transcoded-port binary-port transcoder)~
returns: 一个新的文本端口，有着和 binary-port 一样的字节流 a new textual port with the same byte stream as binary-port
libraries: (rnrs io ports), (rnrs)

This procedure returns a new textual port with transcoder transcoder and the same underlying byte stream as binary-port, positioned at the current position of binary-port.
这个过程返回一个新的文本端口，编码转换器为 transcoder, 底层字节流和 binary-port 一样，定位于 binary-port 的当前位置。

As a side effect of creating the textual port, binary-port is closed to prevent read or write operations on binary-port from interfering with read and write operations on the new textual port. The underlying byte stream remains open, however, until the textual port is closed.
作为创建文本端口的副作用，binary-port 会被关闭，以防止在 binary-port 上的读写操作和在新的文本端口上的读写操作会互相干扰。不过，底层字节流会保持开启，直到此文本端口被关闭。

procedure: ~(port-transcoder port)~
returns: 与 port 相关联的编码转换器（如果存在的话），否则为 #f
libraries: (rnrs io ports), (rnrs)

This procedure always returns #f for binary ports and may return #f for some textual ports.
这个过程对二进制端口总是返回 #f, 而对某些文本端口可能返回 #f.

procedure: ~(port-position port)~
returns: port 的当前位置
procedure: ~(port-has-port-position? port)~
返回: 如果 ~port~ 支持 port-position，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs)

A port may allow queries to determine its current position in the underlying stream of bytes or characters. If so, the procedure port-has-port-position? returns #t and port-position returns the current position. For binary ports, the position is always an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character displacement in the underlying stream. The position may be used at some later time to reset the position if the port supports set-port-position!. If port-position is called on a port that does not support it, an exception with condition type &assertion is raised.
端口可能支持查询以确定它的底层字节或字符流中的当前位置。如果是这样，过程 port-has-port-position? 返回 #t, 而 port-position 返回当前位置。对于二进制端口，位置总是一个精确的非负整数的，从字节流起始位置起的字节偏移量。对于文本端口，位置的表示形式是未定义的；它可能不是一个精确的非负整数，而即使它是，它可能也不表示底层流的字节或字符偏移量。如果端口支持 set-port-position!, 位置可以在之后用于重置位置。如果在一个不支持 port-position 的端口上调用它，会抛出一个条件类型的 &assertion 异常。

procedure: ~(set-port-position! port pos)~
returns: unspecified
procedure: ~(port-has-set-port-position!? port)~
返回: 如果 ~port~ 支持 set-port-position!，则为 ~#t~, 否则为 ~#f~.
libraries: (rnrs io ports), (rnrs)

A port may allow its current position to be moved directly to a different position in the underlying stream of bytes or characters. If so, the procedure port-has-set-port-position!? returns #t and set-port-position! changes the current position. For binary ports, the position pos must be an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified, as described in the entry for port-position above, but pos must be an appropriate position for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to port-position on the same port. If set-port-position! is called on a port that does not support it, an exception with condition type &assertion is raised.
一个端口可能允许把它的当前位置直接移动到底层字节或字符流中的一个不同位置。如果这样的话，过程 port-has-set-port-position!? 返回 #t, 而 set-port-position! 改变当前位置。对于二进制端口，位置 pos 必须是一个精确非负整数的，从字节流起始位置起的字节偏移量。对于文本端口，位置的表示形式是未定义的，如同上面 port-position 条目中所介绍的，但 pos 必须是文本端口的一个适当的位置，通常只有在它是从相同端口上对 port-position 的调用中获得时，才能确保如此。如果在不支持 set-port-position! 的端口上调用它，会抛出一个条件类型的 &assertion 异常。

If port is a binary output port and the position is set beyond the current end of the data in the underlying stream, the stream is not extended until new data is written at that position. If new data is written at that position, the contents of each intervening position is unspecified. Binary ports created with open-file-output-port and open-file-input/output-port can always be extended in this manner within the limits of the underlying operating system. In other cases, attempts to set the port beyond the current end of data in the underlying object may result in an exception with condition type &i/o-invalid-position.
如果端口是二进制输出端口，而设定的位置超过了底层流中数据的当前末尾，则直到向那个位置写入新数据时，流才会扩展。如果向那个位置写入新数据，则每个中间位置的内容为未定义的。通过 open-file-output-port 和 open-file-input/output-port 创建的二进制端口，总是能以这种方式扩展，只要不超出底层操作系统的限制。在其它情况下，尝试把端口设定到超出底层对象中数据的当前末尾的位置时，可能会引起条件类型的&i/o-invalid-position 异常。

procedure: ~(call-with-port port procedure)~
returns: procedure 返回的值
libraries: (rnrs io ports), (rnrs)

call-with-port 以 port 作为唯一实参调用 procedure. 如果 procedure 返回， 则 call-with-port 关闭端口，并返回 procedure 返回的值。

如果一个创建于 procedure 之外的 continuation 被调用，则 call-with-port 不会自动关闭端口，因为之后可能会有另一个创建于 procedure 之内的 continuation 被调用，并把控制权返还给 procedure. 如果 procedure 没有返回，则只有在实现可以确认此输出端口不再可以被访问时，才可以自由地关闭此端口。
does not automatically close the port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the port only if it can prove that the output port is no longer accessible.

The example below copies the contents of infile to outfile, overwriting outfile if it exists. Unless an error occurs, the ports are closed after the copy has been completed.
以下的例子，把输入文件的内容复制到输出文件，如果输出文件已存在，则被覆盖。除非发生错误，不然在复制结束后端口即被关闭。

#+begin_src scheme
(call-with-port (open-file-input-port "infile" (file-options)
                  (buffer-mode block) (native-transcoder))
  (lambda (ip)
    (call-with-port (open-file-output-port "outfile"
                      (file-options no-fail)
                      (buffer-mode block)
                      (native-transcoder)) 
      (lambda (op)
        (do ([c (get-char ip) (get-char ip)])
            ((eof-object? c))
          (put-char op c))))))
#+end_src

A definition of call-with-port is given on page 135.
call-with-port 的定义在 135 页给出。

procedure: ~(output-port-buffer-mode port)~
returns: 表示 port 缓冲模式的符号
libraries: (rnrs io ports), (rnrs)

** Section 7.7. Input Operations

Procedures whose primary purpose is to read data from an input port are described in this section, along with related procedures for recognizing or creating end-of-file (eof) objects.

procedure: ~(eof-object? obj)~
returns: #t if obj is an eof object, #f otherwise
libraries: (rnrs io ports), (rnrs io simple), (rnrs)

The end-of-file object is returned by input operations, e.g., get-datum, when an input port has reached the end of input.

procedure: ~(eof-object)~
returns: the eof object
libraries: (rnrs io ports), (rnrs io simple), (rnrs)

#+begin_src scheme
(eof-object? (eof-object)) => #t
#+end_src

procedure: ~(get-u8 binary-input-port)~
returns: the next byte from binary-input-port, or the eof object
libraries: (rnrs io ports), (rnrs)

If binary-input-port is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255, and the port's position is advanced one byte.

procedure: ~(lookahead-u8 binary-input-port)~
returns: the next byte from binary-input-port, or the eof object
libraries: (rnrs io ports), (rnrs)

If binary-input-port is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255. In contrast to get-u8, lookahead-u8 does not consume the byte it reads from the port, so if the next operation on the port is a call to lookahead-u8 or get-u8, the same byte is returned.

procedure: ~(get-bytevector-n binary-input-port n)~
returns: a nonempty bytevector containing up to n bytes, or the eof object
libraries: (rnrs io ports), (rnrs)

n must be an exact nonnegative integer. If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-n reads (as if with get-u8) as many bytes, up to n, as are available before the port is at end of file, and returns a new (nonempty) bytevector containing these bytes. The port's position is advanced past the bytes read.

procedure: ~(get-bytevector-n! binary-input-port bytevector start n)~
returns: the count of bytes read or the eof object
libraries: (rnrs io ports), (rnrs)

start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of bytevector.

If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-n! reads (as if with get-u8) as many bytes, up to n, as are available before the port is at end of file, stores the bytes in consecutive locations of bytevector starting at start, and returns the count of bytes read as an exact positive integer. The port's position is advanced past the bytes read.

procedure: ~(get-bytevector-some binary-input-port)~
returns: a nonempty bytevector or the eof object
libraries: (rnrs io ports), (rnrs)

If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-some reads (as if with get-u8) at least one byte and possibly more, and returns a bytevector containing these bytes. The port's position is advanced past the bytes read. The maximum number of bytes read by this operation is implementation-dependent.

procedure: ~(get-bytevector-all binary-input-port)~
returns: a nonempty bytevector or the eof object
libraries: (rnrs io ports), (rnrs)

If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-all reads (as if with get-u8) all of the bytes available before the port is at end of file and returns a bytevector containing these bytes. The port's position is advanced past the bytes read.

procedure: ~(get-char textual-input-port)~
returns: the next character from textual-input-port, or the eof object
libraries: (rnrs io ports), (rnrs)

If textual-input-port is at end of file, the eof object is returned. Otherwise, the next available character is returned and the port's position is advanced one character. If textual-input-port is a transcoded port, the position in the underlying byte stream may advance by more than one byte.

procedure: ~(lookahead-char textual-input-port)~
returns: the next character from textual-input-port, or the eof object
libraries: (rnrs io ports), (rnrs)

If textual-input-port is at end of file, the eof object is returned. Otherwise, the next available character is returned. In contrast to get-char, lookahead-char does not consume the character it reads from the port, so if the next operation on the port is a call to lookahead-char or get-char, the same character is returned.

lookahead-char is provided for applications requiring one character of lookahead. The procedure get-word defined below returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since get-word does not know until it sees one character beyond the word that it has read the entire word, it uses lookahead-char to determine the next character and get-char to consume the character.

#+begin_src scheme
(define get-word
  (lambda (p)
    (list->string
      (let f ()
        (let ([c (lookahead-char p)])
          (cond
            [(eof-object? c) '()]
            [(char-alphabetic? c) (get-char p) (cons c (f))]
            [else '()]))))))
#+end_src

procedure: ~(get-string-n textual-input-port n)~
returns: a nonempty string containing up to n characters, or the eof object
libraries: (rnrs io ports), (rnrs)

n must be an exact nonnegative integer. If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-n reads (as if with get-char) as many characters, up to n, as are available before the port is at end of file, and returns a new (nonempty) string containing these characters. The port's position is advanced past the characters read.

procedure: ~(get-string-n! textual-input-port string start n)~
returns: the count of characters read or the eof object
libraries: (rnrs io ports), (rnrs)

start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of string.

If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-n! reads (as if with get-char) as many characters, up to n, as are available before the port is at end of file, stores the characters in consecutive locations of string starting at start, and returns the count of characters read as an exact positive integer. The port's position is advanced past the characters read.

get-string-n! may be used to implement string-set! and string-fill!, as illustrated below, although this is not its primary purpose.

#+begin_src scheme
(define string-set!
  (lambda (s i c)
    (let ([sip (open-string-input-port (string c))])
      (get-string-n! sip s i 1)
     ; return unspecified values:
      (if #f #f))))
#+end_src

#+begin_src scheme
(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (let ([sip (open-string-input-port (make-string n c))])
        (get-string-n! sip s 0 n)
       ; return unspecified values:
        (if #f #f)))))
#+end_src

#+begin_src scheme
(let ([x (make-string 3)])
  (string-fill! x #\-)
  (string-set! x 2 #\))
  (string-set! x 0 #\;)
  x) => ";-)"
#+end_src

procedure: ~(get-string-all textual-input-port)~
returns: a nonempty string or the eof object
libraries: (rnrs io ports), (rnrs)

If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-all reads (as if with get-char) all of the characters available before the port is at end of file and returns a string containing these characters. The port's position is advanced past the characters read.

procedure: ~(get-line textual-input-port)~
returns: a string or the eof object
libraries: (rnrs io ports), (rnrs)

If textual-input-port is at end of file, the eof object is returned. Otherwise, get-line reads (as if with get-char) all of the characters available before the port is at end of file or a line-feed character has been read and returns a string containing all but the line-feed character of the characters read. The port's position is advanced past the characters read.

#+begin_src scheme
(let ([sip (open-string-input-port "one\ntwo\n")])
  (let* ([s1 (get-line sip)] [s2 (get-line sip)])
    (list s1 s2 (port-eof? sip)))) => ("one" "two" #t)
#+end_src

#+begin_src scheme
(let ([sip (open-string-input-port "one\ntwo")])
  (let* ([s1 (get-line sip)] [s2 (get-line sip)])
    (list s1 s2 (port-eof? sip)))) => ("one" "two" #t)
#+end_src

procedure: ~(get-datum textual-input-port)~
returns: a Scheme datum object or the eof object
libraries: (rnrs io ports), (rnrs)

This procedure scans past whitespace and comments to find the start of the external representation of a datum. If textual-input-port reaches end of file before the start of the external representation of a datum is found, the eof object is returned.

Otherwise, get-datum reads as many characters as necessary, and no more, to parse a single datum, and returns a newly allocated object whose structure is determined by the external representation. The port's position is advanced past the characters read. If an end-of-file is reached before the external representation of the datum is complete, or an unexpected character is read, an exception is raised with condition types &lexical and i/o-read.

#+begin_src scheme
(let ([sip (open-string-input-port "; a\n\n one (two)\n")])
  (let* ([x1 (get-datum sip)]
         [c1 (lookahead-char sip)]
         [x2 (get-datum sip)])
    (list x1 c1 x2 (port-eof? sip)))) => (one #\space (two) #f)
#+end_src

procedure: ~(port-eof? input-port)~
returns: #t if input-port is at end-of-file, #f otherwise
libraries: (rnrs io ports), (rnrs)

This procedure is similar to lookahead-u8 on a binary input port or lookahead-char on a textual input port, except that instead of returning the next byte/character or eof object, it returns a boolean value to indicate whether the value would be the eof object.

** Section 7.8. Output Operations

Procedures whose primary purpose is to send data to an output port are described in this section.

procedure: ~(put-u8 binary-output-port octet)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

octet must be an exact nonnegative integer less than or equal to 255. This procedure writes octet to binary-output-port, advancing the port's position by one byte.

procedure: ~(put-bytevector binary-output-port bytevector)~
procedure: ~(put-bytevector binary-output-port bytevector start)~
procedure: ~(put-bytevector binary-output-port bytevector start n)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of bytevector. If not supplied, start defaults to zero and n defaults to the difference between the length of bytevector and start.

This procedure writes the n bytes of bytevector starting at start to the port and advances the its position past the end of the bytes written.

procedure: ~(put-char textual-output-port char)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

This procedure writes char to textual-output-port, advancing the port's position by one character. If textual-output-port is a transcoded port, the position in the underlying byte stream may advance by more than one byte.

procedure: ~(put-string textual-output-port string)~
procedure: ~(put-string textual-output-port string start)~
procedure: ~(put-string textual-output-port string start n)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of string. If not supplied, start defaults to zero and n defaults to the difference between the length of string and start.

This procedure writes the n characters of string starting at start to the port and advances the its position past the end of the characters written.

procedure: ~(put-datum textual-output-port obj)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

This procedure writes an external representation of obj to textual-output-port. If obj does not have an external representation as a datum, the behavior is unspecified. The precise external representation is implementation-dependent, but when obj does have an external representation as a datum, put-datum should produce a sequence of characters that can later be read by get-datum as an object equivalent (in the sense of equal?) to obj. See Section 12.5 for an implementation of put-datum, write, and display.

procedure: ~(flush-output-port output-port)~
returns: unspecified
libraries: (rnrs io ports), (rnrs)

This procedure forces any bytes or characters in the buffer associated with output-port to be sent immediately to the underlying stream.

** Section 7.9. Convenience I/O

The procedures in this section are referred to as "convenience" I/O operators because they present a somewhat simplified interface for creating and interacting with textual ports. They also provide backward compatibility with the Revised5 Report, which did not support separate binary and textual I/O.

The convenience input/output procedures may be called with or without an explicit port argument. If called without an explicit port argument, the current input or output port is used, as appropriate. For example, (read-char) and (read-char (current-input-port)) both return the next character from the current input port.

procedure: ~(open-input-file path)~
returns: a new input port
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. open-input-file creates a new textual input port for the file named by path, as if by open-file-input-port with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.

The following shows the use of open-input-file, read, and close-port in an expression that gathers a list of objects from the file named by "myfile.ss."

#+begin_src scheme
(let ([p (open-input-file "myfile.ss")])
  (let f ([x (read p)])
    (if (eof-object? x)
        (begin
          (close-port p)
          '())
        (cons x (f (read p))))))
#+end_src

procedure: ~(open-output-file path)~
returns: a new output port
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. open-output-file creates a new output port for the file named by path, as if by open-file-output-port with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.

The following shows the use of open-output-file to write a list of objects (the value of list-to-be-printed), separated by newlines, to the file named by "myfile.ss."

#+begin_src scheme
(let ([p (open-output-file "myfile.ss")])
  (let f ([ls list-to-be-printed])
    (if (not (null? ls))
        (begin
          (write (car ls) p)
          (newline p)
          (f (cdr ls)))))
  (close-port p))
#+end_src

procedure: ~(call-with-input-file path procedure)~
returns: the values returned by procedure
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. procedure should accept one argument.

call-with-input-file creates a new input port for the file named by path, as if with open-input-file, and passes this port to procedure. If procedure returns, call-with-input-file closes the input port and returns the values returned by procedure.

call-with-input-file does not automatically close the input port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section 5.6, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked.

The following example shows the use of call-with-input-file in an expression that gathers a list of objects from the file named by "myfile.ss." It is functionally equivalent to the example given for open-input-file above.

#+begin_src scheme
(call-with-input-file "myfile.ss"
  (lambda (p)
    (let f ([x (read p)])
      (if (eof-object? x)
          '()
          (cons x (f (read p)))))))
#+end_src

call-with-input-file might be defined without error checking as follows.

#+begin_src scheme
(define call-with-input-file
  (lambda (filename proc)
    (let ([p (open-input-file filename)])
      (let-values ([v* (proc p)])
        (close-port p)
        (apply values v*)))))
#+end_src

procedure: ~(call-with-output-file path procedure)~
returns: the values returned by procedure
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. procedure should accept one argument.

call-with-output-file creates a new output port for the file named by path, as if with open-output-file, and passes this port to procedure. If procedure returns, call-with-output-file closes the output port and returns the values returned by procedure.

call-with-output-file does not automatically close the output port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section 5.6, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked.

The following shows the use of call-with-output-file to write a list of objects (the value of list-to-be-printed), separated by newlines, to the file named by "myfile.ss." It is functionally equivalent to the example given for open-output-file above.

#+begin_src scheme
(call-with-output-file "myfile.ss"
  (lambda (p)
    (let f ([ls list-to-be-printed])
      (unless (null? ls)
        (write (car ls) p)
        (newline p)
        (f (cdr ls))))))
#+end_src

call-with-output-file might be defined without error checking as follows.

#+begin_src scheme
(define call-with-output-file
  (lambda (filename proc)
    (let ([p (open-output-file filename)])
      (let-values ([v* (proc p)])
        (close-port p)
        (apply values v*)))))
#+end_src

procedure: ~(with-input-from-file path thunk)~
returns: the values returned by thunk
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. thunk must be a procedure and should accept zero arguments.

with-input-from-file temporarily changes the current input port to be the result of opening the file named by path, as if with open-input-file, during the application of thunk. If thunk returns, the port is closed and the current input port is restored to its old value.

The behavior of with-input-from-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current input port to its old value---but it may not.

procedure: ~(with-output-to-file path thunk)~
returns: the values returned by thunk
libraries: (rnrs io simple), (rnrs)

path must be a string or some other implementation-dependent value that names a file. thunk must be a procedure and should accept zero arguments.

with-output-to-file temporarily rebinds the current output port to be the result of opening the file named by path, as if with open-output-file, during the application of thunk. If thunk returns, the port is closed and the current output port is restored to its old value.

The behavior of with-output-to-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current output port to its old value---but it may not.

procedure: ~(read)~
procedure: ~(read textual-input-port)~
returns: a Scheme datum object or the eof object
libraries: (rnrs io simple), (rnrs)

If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to get-datum.

procedure: ~(read-char)~
procedure: ~(read-char textual-input-port)~
returns: the next character from textual-input-port
libraries: (rnrs io simple), (rnrs)

If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to get-char.

procedure: ~(peek-char)~
procedure: ~(peek-char textual-input-port)~
returns: the next character from textual-input-port
libraries: (rnrs io simple), (rnrs)

If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to lookahead-char.

procedure: ~(write obj)~
procedure: ~(write obj textual-output-port)~
returns: unspecified
libraries: (rnrs io simple), (rnrs)

If textual-output-port is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to put-datum, with the arguments reversed. See Section 12.5 for an implementation of put-datum, write, and display.

procedure: ~(display obj)~
procedure: ~(display obj textual-output-port)~
returns: unspecified
libraries: (rnrs io simple), (rnrs)

If textual-output-port is not supplied, it defaults to the current output port.

display is similar to write or put-datum but prints strings and characters found within obj directly. Strings are printed without quotation marks or escapes for special characters, as if by put-string, and characters are printed without the #\ notation, as if by put-char. With display, the three-element list (a b c) and the two-element list ("a b" c) both print as (a b c). Because of this, display should not be used to print objects that are intended to be read with read. display is useful primarily for printing messages, with obj most often being a string. See Section 12.5 for an implementation of put-datum, write, and display.

procedure: ~(write-char char)~
procedure: ~(write-char char textual-output-port)~
returns: unspecified
libraries: (rnrs io simple), (rnrs)

If textual-output-port is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to put-char, with the arguments reversed.

procedure: ~(newline)~
procedure: ~(newline textual-output-port)~
returns: unspecified
libraries: (rnrs io simple), (rnrs)

If textual-output-port is not supplied, it defaults to the current output port. newline sends a line-feed character to the port.

procedure: ~(close-input-port input-port)~
procedure: ~(close-output-port output-port)~
returns: unspecified
libraries: (rnrs io simple), (rnrs)

close-input-port closes an input port, and close-output-port closes an output port. These procedures are provided for backward compatibility with the Revised5 Report; they are not actually more convenient to use than close-port.

** Section 7.10. Filesystem Operations

Scheme has two standard operations, beyond file input/output, for interacting with the filesystem: file-exists? and delete-file. Most implementations support additional operations.

procedure: ~(file-exists? path)~
returns: #t if the file named by path exists, #f otherwise
libraries: (rnrs files), (rnrs)

path must be a string or some other implementation-dependent value that names a file. Whether file-exists? follows symbolic links is unspecified.

procedure: ~(delete-file path)~
returns: unspecified
libraries: (rnrs files), (rnrs)

path must be a string or some other implementation-dependent value that names a file. delete-file removes the file named by path if it exists and can be deleted, otherwise it raises an exception with condition type &i/o-filename. Whether delete-file follows symbolic links is unspecified.

** Section 7.11. Bytevector/String Conversions

The procedures described in this section encode or decode character sequences, converting from strings to bytevectors or bytevectors to strings. They do not necessarily involve input/output, though they might be implemented using bytevector input and output ports.

The first two procedures, bytevector->string and string->bytevector, take an explicit transcoder argument that determines the character encodings, eol styles, and error-handling modes. The others perform specific Unicode conversions with an implicit eol-style of none and error-handling mode of replace.

procedure: ~(bytevector->string bytevector transcoder)~
returns: a string containing the characters encoded in bytevector
libraries: (rnrs io ports), (rnrs)

This operation, at least in effect, creates a bytevector input port with the specified transcoder from which all of the available characters are read, as if by get-string-all, and placed into the output string.

#+begin_src scheme
(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)
            (error-handling-mode replace))])
  (bytevector->string #vu8(97 98 99) tx)) => "abc"
#+end_src

procedure: ~(string->bytevector string transcoder)~
returns: a bytevector containing the encodings of the characters in string
libraries: (rnrs io ports), (rnrs)

This operation, at least in effect, creates a bytevector output port with the specified transcoder to which all of the characters of string are written, then extracts a bytevector containing the accumulated bytes.

#+begin_src scheme
(let ([tx (make-transcoder (utf-8-codec) (eol-style none)
            (error-handling-mode raise))])
  (string->bytevector "abc" tx)) => #vu8(97 98 99)
#+end_src

procedure: ~(string->utf8 string)~
returns: a bytevector containing the UTF-8 encoding of string
libraries: (rnrs bytevectors), (rnrs)

procedure: ~(string->utf16 string)~
procedure: ~(string->utf16 string endianness)~
procedure: ~(string->utf32 string)~
procedure: ~(string->utf32 string endianness)~
returns: a bytevector containing the specified encoding of string
libraries: (rnrs bytevectors), (rnrs)

endianness must be one of the symbols big or little. If endianness is not provided or is the symbol big, string->utf16 returns the UTF-16BE encoding of string and string->utf32 returns the UTF-32BE encoding of string. If endianness is the symbol little, string->utf16 returns the UTF-16LE encoding of string and string->utf32 returns the UTF-32LE encoding of string. No byte-order mark is included in the encoding.

procedure: ~(utf8->string bytevector)~
returns: a string containing the UTF-8 decoding of bytevector
libraries: (rnrs bytevectors), (rnrs)

procedure: ~(utf16->string bytevector endianness)~
procedure: ~(utf16->string bytevector endianness endianness-mandatory?)~
procedure: ~(utf32->string bytevector endianness)~
procedure: ~(utf32->string bytevector endianness endianness-mandatory?)~
returns: a string containing the specified decoding of bytevector
libraries: (rnrs bytevectors), (rnrs)

endianness must be one of the symbols big or little. These procedures return a UTF-16 or UTF-32 decoding of bytevector, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If endianness-mandatory? is not provided or is #f, the endianness is determined by a BOM at the front of bytevector or, if no BOM is present, by endianness. If endianness-mandatory? is #t, the endianness is determined by endianness, and, if a BOM appears at the front of bytevector, it is treated as a regular character encoding.

The UTF-16 BOM is the two-byte sequence #xFE, #xFF specifying "big" or the two-byte sequence #xFF, #xFE specifying "little." The UTF-32 BOM is the four-byte sequence #x00, #x00, #xFE, #xFF specifying "big" or the four-byte sequence #xFF, #xFE, #x00, #x00 specifying "little."

R. Kent Dybvig / The Scheme Programming Language, Fourth Edition
Copyright © 2009 The MIT Press. Electronically reproduced by permission.
Illustrations © 2009 Jean-Pierre Hébert
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
to order this book / about this book

http://www.scheme.com
